<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inviwo: inviwo::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="inviwo_dark.png"/></td>
  <td id="projectalign">
   <div id="projectname">Inviwo<span id="projectnumber">&#160;0.9.11.1</span>
   </div>
   <div id="projectbrief">Inviwo documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceinviwo_1_1util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">inviwo::util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1alwaysTrue.html">alwaysTrue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1BrickIterator.html">BrickIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator providing access to a subregion, or brick, within linearized 3D data.  <a href="classinviwo_1_1util_1_1BrickIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BufferDispatcher.html">BufferDispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides information on build time and date as well as git hashes.  <a href="structinviwo_1_1util_1_1BuildInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Camera2D.html">Camera2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype.html">cameratype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype_3_012_01_4.html">cameratype&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1cameratype_3_013_01_4.html">cameratype&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1cloneable__ptr.html">cloneable_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Combinations.html">Combinations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation.html">DefaultColorRepresentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation_3_01ivec3_01_4.html">DefaultColorRepresentation&lt; ivec3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultColorRepresentation_3_01ivec4_01_4.html">DefaultColorRepresentation&lt; ivec4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1DefaultTraversalFilter.html">DefaultTraversalFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1extent_3_01const_01T_00_01N_01_4.html">extent&lt; const T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::mat&lt; C, R, T, Q &gt;, 1 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::tquat&lt; T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>extent&lt; glm::vec&lt; L, T, Q &gt;, 0 &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1flat__extent.html">flat_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type.html">for_each_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type_3_01std_1_1tuple_3_01T_00_01Types_8_8_8_01_4_01_4.html">for_each_type&lt; std::tuple&lt; T, Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair.html">for_each_type_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1for__each__type__pair_3_01std_1_1tuple_3_01ATypes_8_8_8_01_4_00_01std_1_980543efefbc8ab89773d2539d3c1f94.html">for_each_type_pair&lt; std::tuple&lt; ATypes... &gt;, std::tuple&lt; BTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype.html">glmtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_011_00_011_00_01P_01_4.html">glmtype&lt; T, 1, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1glmtype_3_01T_00_01L_00_011_00_01P_01_4.html">glmtype&lt; T, L, 1, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1GridPos.html">GridPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1HasDataFormat.html">HasDataFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1HasEnumName.html">HasEnumName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IdentifiedDeserializer.html">IdentifiedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1identity.html">identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IndexedDeserializer.html">IndexedDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_012_00_01IndexType_01_4.html">IndexMapper&lt; 2, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndexMapper_3_013_00_01IndexType_01_4.html">IndexMapper&lt; 3, IndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1IndexProduct.html">IndexProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__container.html">is_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable.html">is_dereferenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__dereferenceable_3_01T_00_01std_1_1void__t_3_01decltype_07_5std_1_1dea79db0978b6be7e835bcf0aa2839bd26.html">is_dereferenceable&lt; T, std::void_t&lt; decltype(*std::declval&lt; T &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__floating__point_3_01half__float_1_1half_01_4.html">is_floating_point&lt; half_float::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1is__stream__insertable.html">is_stream_insertable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1is__string.html">is_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1IterRangeGenerator.html">IterRangeGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1KeepTrueWhileInScope.html">KeepTrueWhileInScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the given bool variable to true and restores its state when leaving the scope  <a href="classinviwo_1_1util_1_1KeepTrueWhileInScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MapDeserializer.html">MapDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MemoryFileHandle.html">MemoryFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII class for providing a FILE stream handle to a buffer in memory. This class will open a file handle to /dev/null and use a dedicated buffer for buffering. As long as less bytes than getBufferSize() bytes are written/read, its status is well defined. However, after writing more than buffer size bytes, the buffer contents will be flushed, i.e. are no longer accessible.  <a href="classinviwo_1_1util_1_1MemoryFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1MetaDataToProperty.html">MetaDataToProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1NotificationBlocker.html">NotificationBlocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1OnScopeExit.html">OnScopeExit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls the given function when leaving the current scope  <a href="structinviwo_1_1util_1_1OnScopeExit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1overloaded.html">overloaded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1Permutations.html">Permutations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1PropertyDistanceSorter.html">PropertyDistanceSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank.html">rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank_3_01const_01T_01_4.html">rank&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>rank&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1rank_3_01half__float_1_1half_01_4.html">rank&lt; half_float::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1same__extent.html">same_extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::mat&lt; C, R, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::tquat&lt; T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>same_extent&lt; glm::vec&lt; L, T, Q &gt;, U &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TempFileHandle.html">TempFileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII interface for providing a file handle and file name to a temporary file.  <a href="classinviwo_1_1util_1_1TempFileHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TextureAtlas.html">TextureAtlas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classinviwo_1_1Texture.html">Texture</a> atlas for a number of strings rendered with the <a class="el" href="classinviwo_1_1TextRenderer.html" title="Render text using the FreeType font library.">TextRenderer</a>.  <a href="classinviwo_1_1util_1_1TextureAtlas.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1TFPropertyConcept.html">TFPropertyConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">property interface used by the TF dialog to support different TF properties  <a href="structinviwo_1_1util_1_1TFPropertyConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinviwo_1_1util_1_1TFPropertyModel.html">TFPropertyModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1TransformIterator.html">TransformIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinviwo_1_1util_1_1value__type.html">value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::mat&lt; C, R, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::tquat&lt; T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>value_type&lt; glm::vec&lt; L, T, Q &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1933818b2c5a7fdb8835d5d166115350"><td class="memTemplParams" colspan="2"><a id="a1933818b2c5a7fdb8835d5d166115350" name="a1933818b2c5a7fdb8835d5d166115350"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1933818b2c5a7fdb8835d5d166115350"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>classIdentifierType</b> = decltype(std::declval&lt; T &gt;().getClassIdentifier())</td></tr>
<tr class="separator:a1933818b2c5a7fdb8835d5d166115350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ccaf4c7b8d5d02444f368166dc661d"><td class="memTemplParams" colspan="2"><a id="a69ccaf4c7b8d5d02444f368166dc661d" name="a69ccaf4c7b8d5d02444f368166dc661d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a69ccaf4c7b8d5d02444f368166dc661d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasGetClassIdentifier</b> = is_detected_exact&lt; std::string, classIdentifierType, T &gt;</td></tr>
<tr class="separator:a69ccaf4c7b8d5d02444f368166dc661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82b365b74ed9c4318f2a4bfd9ffe6c6"><td class="memTemplParams" colspan="2"><a id="ab82b365b74ed9c4318f2a4bfd9ffe6c6" name="ab82b365b74ed9c4318f2a4bfd9ffe6c6"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:ab82b365b74ed9c4318f2a4bfd9ffe6c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt; <a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::value_t</td></tr>
<tr class="separator:ab82b365b74ed9c4318f2a4bfd9ffe6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe658e21457589433214732a2db7dedf"><td class="memTemplParams" colspan="2"><a id="afe658e21457589433214732a2db7dedf" name="afe658e21457589433214732a2db7dedf"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:afe658e21457589433214732a2db7dedf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt; <a class="el" href="structinviwo_1_1util_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="separator:afe658e21457589433214732a2db7dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d6953fb67d55ccadc9b35f50b7e71a"><td class="memTemplParams" colspan="2"><a id="a52d6953fb67d55ccadc9b35f50b7e71a" name="a52d6953fb67d55ccadc9b35f50b7e71a"></a>
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a52d6953fb67d55ccadc9b35f50b7e71a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or</b> = <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detail::detector</a>&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="separator:a52d6953fb67d55ccadc9b35f50b7e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c5dc384b2da0c5e448b74572ad25f8"><td class="memTemplParams" colspan="2"><a id="a18c5dc384b2da0c5e448b74572ad25f8" name="a18c5dc384b2da0c5e448b74572ad25f8"></a>
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a18c5dc384b2da0c5e448b74572ad25f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1detail_1_1detector.html">detected_or</a>&lt; Default, Op, Args... &gt;::type</td></tr>
<tr class="separator:a18c5dc384b2da0c5e448b74572ad25f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04992c124335231e5ab1c936db6755d3"><td class="memTemplParams" colspan="2"><a id="a04992c124335231e5ab1c936db6755d3" name="a04992c124335231e5ab1c936db6755d3"></a>
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a04992c124335231e5ab1c936db6755d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact</b> = std::is_same&lt; Expected, detected_t&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="separator:a04992c124335231e5ab1c936db6755d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d74b2511d58cc2570e145968d7a12d0"><td class="memTemplParams" colspan="2"><a id="a9d74b2511d58cc2570e145968d7a12d0" name="a9d74b2511d58cc2570e145968d7a12d0"></a>
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a9d74b2511d58cc2570e145968d7a12d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible</b> = std::is_convertible&lt; detected_t&lt; Op, Args... &gt;, To &gt;</td></tr>
<tr class="separator:a9d74b2511d58cc2570e145968d7a12d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5f1041e36b51c7bdbeb40c5d836fc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b5f1041e36b51c7bdbeb40c5d836fc0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">PrecisionType</a> = typename std::remove_pointer&lt; typename std::remove_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="separator:a2b5f1041e36b51c7bdbeb40c5d836fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memTemplParams" colspan="2"><a id="ade565d10867e0dc26e164bd60ff9ef6c" name="ade565d10867e0dc26e164bd60ff9ef6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrecsionType</b> = typename std::remove_pointer&lt; typename std::remove_const&lt; T &gt;::type &gt;::type</td></tr>
<tr class="separator:ade565d10867e0dc26e164bd60ff9ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46a88fc5a27a696a911ff806d367b56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab46a88fc5a27a696a911ff806d367b56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab46a88fc5a27a696a911ff806d367b56">PrecisionValueType</a> = typename <a class="el" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">PrecisionType</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ab46a88fc5a27a696a911ff806d367b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb80bb22766e5ca8d698e1d5a7da25a"><td class="memTemplParams" colspan="2"><a id="a9eb80bb22766e5ca8d698e1d5a7da25a" name="a9eb80bb22766e5ca8d698e1d5a7da25a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9eb80bb22766e5ca8d698e1d5a7da25a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrecsionValueType</b> = typename <a class="el" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">PrecisionType</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a9eb80bb22766e5ca8d698e1d5a7da25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6e896cf8eabc31472d99d9926c26c5"><td class="memTemplParams" colspan="2"><a id="aca6e896cf8eabc31472d99d9926c26c5" name="aca6e896cf8eabc31472d99d9926c26c5"></a>
template&lt;typename T  = double, glm::length_t C = 1, glm::length_t R = 1, glm::qualifier Q = glm::defaultp&gt; </td></tr>
<tr class="memitem:aca6e896cf8eabc31472d99d9926c26c5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmtype_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1glmtype.html">glmtype</a>&lt; T, C, R, Q &gt;::type</td></tr>
<tr class="separator:aca6e896cf8eabc31472d99d9926c26c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394960231300081a682d61a7865f63e1"><td class="memTemplParams" colspan="2"><a id="a394960231300081a682d61a7865f63e1" name="a394960231300081a682d61a7865f63e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a394960231300081a682d61a7865f63e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value_type_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1value__type.html">value_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a394960231300081a682d61a7865f63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa91b43c4237fbac515477f154754f6"><td class="memTemplParams" colspan="2"><a id="affa91b43c4237fbac515477f154754f6" name="affa91b43c4237fbac515477f154754f6"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:affa91b43c4237fbac515477f154754f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>same_extent_t</b> = typename <a class="el" href="structinviwo_1_1util_1_1same__extent.html">same_extent</a>&lt; T, U &gt;::type</td></tr>
<tr class="separator:affa91b43c4237fbac515477f154754f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f92cc22201b6bdb0121dfae46e921fc"><td class="memItemLeft" align="right" valign="top"><a id="a7f92cc22201b6bdb0121dfae46e921fc" name="a7f92cc22201b6bdb0121dfae46e921fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper2D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt; 2, size_t &gt;</td></tr>
<tr class="separator:a7f92cc22201b6bdb0121dfae46e921fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788768f656d806bf88fefaef7dc4e4db"><td class="memItemLeft" align="right" valign="top"><a id="a788768f656d806bf88fefaef7dc4e4db" name="a788768f656d806bf88fefaef7dc4e4db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IndexMapper3D</b> = <a class="el" href="structinviwo_1_1util_1_1IndexMapper.html">IndexMapper</a>&lt; 3, size_t &gt;</td></tr>
<tr class="separator:a788768f656d806bf88fefaef7dc4e4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc66170827118d713b8249a1ba23883"><td class="memTemplParams" colspan="2"><a id="aafc66170827118d713b8249a1ba23883" name="aafc66170827118d713b8249a1ba23883"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aafc66170827118d713b8249a1ba23883"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasClassIdentifierUpper</b> = is_detected_exact&lt; const std::string, detail::upperClassIdentifierType, T &gt;</td></tr>
<tr class="separator:aafc66170827118d713b8249a1ba23883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b57508f883c800e26185a413200c1f7"><td class="memTemplParams" colspan="2"><a id="a8b57508f883c800e26185a413200c1f7" name="a8b57508f883c800e26185a413200c1f7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b57508f883c800e26185a413200c1f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasClassIdentifierLower</b> = is_detected_exact&lt; const std::string, detail::lowerClassIdentifierType, T &gt;</td></tr>
<tr class="separator:a8b57508f883c800e26185a413200c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3ab5ca75ac3344a51422ad53739e3"><td class="memTemplParams" colspan="2"><a id="a5bd3ab5ca75ac3344a51422ad53739e3" name="a5bd3ab5ca75ac3344a51422ad53739e3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5bd3ab5ca75ac3344a51422ad53739e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasClassIdentifier</b> = std::disjunction&lt; HasClassIdentifierUpper&lt; T &gt;, HasClassIdentifierLower&lt; T &gt; &gt;</td></tr>
<tr class="separator:a5bd3ab5ca75ac3344a51422ad53739e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac718add75e226231178d42843cae8de0"><td class="memTemplParams" colspan="2"><a id="ac718add75e226231178d42843cae8de0" name="ac718add75e226231178d42843cae8de0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac718add75e226231178d42843cae8de0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasDataName</b> = is_detected_exact&lt; const std::string, detail::dataNameType, T &gt;</td></tr>
<tr class="separator:ac718add75e226231178d42843cae8de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b87bdcfb4ca7a2317ebcfcf3ff530"><td class="memTemplParams" colspan="2"><a id="a228b87bdcfb4ca7a2317ebcfcf3ff530" name="a228b87bdcfb4ca7a2317ebcfcf3ff530"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a228b87bdcfb4ca7a2317ebcfcf3ff530"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasColorCodeUpper</b> = is_detected_exact&lt; uvec3, detail::colorCodeUpperType, T &gt;</td></tr>
<tr class="separator:a228b87bdcfb4ca7a2317ebcfcf3ff530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c88e96df15106507a43ff4a41b672da"><td class="memTemplParams" colspan="2"><a id="a9c88e96df15106507a43ff4a41b672da" name="a9c88e96df15106507a43ff4a41b672da"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c88e96df15106507a43ff4a41b672da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasColorCodeLower</b> = is_detected_exact&lt; uvec3, detail::colorCodeLowerType, T &gt;</td></tr>
<tr class="separator:a9c88e96df15106507a43ff4a41b672da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af553fc739228c8ad9c64cfbc45f46d78"><td class="memTemplParams" colspan="2"><a id="af553fc739228c8ad9c64cfbc45f46d78" name="af553fc739228c8ad9c64cfbc45f46d78"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af553fc739228c8ad9c64cfbc45f46d78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasColorCode</b> = std::disjunction&lt; HasColorCodeUpper&lt; T &gt;, HasColorCodeLower&lt; T &gt; &gt;</td></tr>
<tr class="separator:af553fc739228c8ad9c64cfbc45f46d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6a49105dc8aa1f072f182584eceda5"><td class="memTemplParams" colspan="2"><a id="aff6a49105dc8aa1f072f182584eceda5" name="aff6a49105dc8aa1f072f182584eceda5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff6a49105dc8aa1f072f182584eceda5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasDataInfo</b> = is_detected_exact&lt; std::string, detail::dataInfoType, T &gt;</td></tr>
<tr class="separator:aff6a49105dc8aa1f072f182584eceda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa415d1db7c35672fbe3d2a488ac2cc"><td class="memTemplParams" colspan="2"><a id="a1aa415d1db7c35672fbe3d2a488ac2cc" name="a1aa415d1db7c35672fbe3d2a488ac2cc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aa415d1db7c35672fbe3d2a488ac2cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HasInfo</b> = is_detected_exact&lt; <a class="el" href="classinviwo_1_1Document.html">Document</a>, detail::infoType, T &gt;</td></tr>
<tr class="separator:a1aa415d1db7c35672fbe3d2a488ac2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c468609df4a639a947be6b7b971ec3f"><td class="memTemplParams" colspan="2"><a id="a3c468609df4a639a947be6b7b971ec3f" name="a3c468609df4a639a947be6b7b971ec3f"></a>
template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a3c468609df4a639a947be6b7b971ec3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_invocable</b> = std::is_invocable&lt; F, Args... &gt;</td></tr>
<tr class="separator:a3c468609df4a639a947be6b7b971ec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a24c90ae109a9bfca01bbc805189aa"><td class="memTemplParams" colspan="2"><a id="ae5a24c90ae109a9bfca01bbc805189aa" name="ae5a24c90ae109a9bfca01bbc805189aa"></a>
template&lt;typename R , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:ae5a24c90ae109a9bfca01bbc805189aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_invocable_r</b> = std::is_invocable_r&lt; F, Args... &gt;</td></tr>
<tr class="separator:ae5a24c90ae109a9bfca01bbc805189aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68cc926f3f2545bbdcf33a3f6a700a0"><td class="memTemplParams" colspan="2"><a id="ad68cc926f3f2545bbdcf33a3f6a700a0" name="ad68cc926f3f2545bbdcf33a3f6a700a0"></a>
template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:ad68cc926f3f2545bbdcf33a3f6a700a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_callable</b> = std::is_invocable&lt; F, Args... &gt;</td></tr>
<tr class="separator:ad68cc926f3f2545bbdcf33a3f6a700a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a63ab9cda788314e4a57788af20b8effd"><td class="memItemLeft" align="right" valign="top"><a id="a63ab9cda788314e4a57788af20b8effd" name="a63ab9cda788314e4a57788af20b8effd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>UseUnitPrefixes</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:a63ab9cda788314e4a57788af20b8effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a21db522a804cf93c00863b5dfd76f"><td class="memItemLeft" align="right" valign="top"><a id="af7a21db522a804cf93c00863b5dfd76f" name="af7a21db522a804cf93c00863b5dfd76f"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalDirection</b> { <b>Up</b>
, <b>Down</b>
 }</td></tr>
<tr class="separator:af7a21db522a804cf93c00863b5dfd76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aa2caf857929fd4da8450f78b1c4d9"><td class="memItemLeft" align="right" valign="top"><a id="a58aa2caf857929fd4da8450f78b1c4d9" name="a58aa2caf857929fd4da8450f78b1c4d9"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>VisitPattern</b> { <b>Pre</b>
, <b>Post</b>
 }</td></tr>
<tr class="separator:a58aa2caf857929fd4da8450f78b1c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d369980e91d789b8e912967f375ab4"><td class="memItemLeft" align="right" valign="top"><a id="ad5d369980e91d789b8e912967f375ab4" name="ad5d369980e91d789b8e912967f375ab4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>DryRun</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:ad5d369980e91d789b8e912967f375ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7df44ff09cb0549d16a59863813359"><td class="memItemLeft" align="right" valign="top"><a id="a3b7df44ff09cb0549d16a59863813359" name="a3b7df44ff09cb0549d16a59863813359"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>OverwriteState</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:a3b7df44ff09cb0549d16a59863813359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b7c5a6156793bd1e87dec727b16af2"><td class="memItemLeft" align="right" valign="top"><a id="a50b7c5a6156793bd1e87dec727b16af2" name="a50b7c5a6156793bd1e87dec727b16af2"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>VolumeLaplacianPostProcessing</b> { <b>None</b>
, <b>Normalized</b>
, <b>SignNormalized</b>
, <b>Scaled</b>
 }</td></tr>
<tr class="separator:a50b7c5a6156793bd1e87dec727b16af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af34749eafa4599470bfa476d692837b7"><td class="memItemLeft" align="right" valign="top"><a id="af34749eafa4599470bfa476d692837b7" name="af34749eafa4599470bfa476d692837b7"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode</b> (util::span&lt; char &gt; s, bool url=false)</td></tr>
<tr class="separator:af34749eafa4599470bfa476d692837b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae567137c10aacef0178798f725c86cdf"><td class="memItemLeft" align="right" valign="top"><a id="ae567137c10aacef0178798f725c86cdf" name="ae567137c10aacef0178798f725c86cdf"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode_pem</b> (util::span&lt; char &gt; s)</td></tr>
<tr class="separator:ae567137c10aacef0178798f725c86cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae54003f61b5957c0ed83ab31237127"><td class="memItemLeft" align="right" valign="top"><a id="a5ae54003f61b5957c0ed83ab31237127" name="a5ae54003f61b5957c0ed83ab31237127"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode_mime</b> (util::span&lt; char &gt; s)</td></tr>
<tr class="separator:a5ae54003f61b5957c0ed83ab31237127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0721194f56ccea706c8eb3e5b1d2c38d"><td class="memItemLeft" align="right" valign="top"><a id="a0721194f56ccea706c8eb3e5b1d2c38d" name="a0721194f56ccea706c8eb3e5b1d2c38d"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (std::string_view s, bool remove_linebreaks=false)</td></tr>
<tr class="separator:a0721194f56ccea706c8eb3e5b1d2c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a73f5197bbfc5940421cee5d8f5755"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a74a73f5197bbfc5940421cee5d8f5755">boundingBox</a> (const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:a74a73f5197bbfc5940421cee5d8f5755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a49c8d7b70aa04748e46e77aaa4bf3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa7a49c8d7b70aa04748e46e77aaa4bf3">boundingBox</a> (const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &gt; &amp;meshes)</td></tr>
<tr class="separator:aa7a49c8d7b70aa04748e46e77aaa4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b304bd97447cbc99865cf2a8bdc3a9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ac6b304bd97447cbc99865cf2a8bdc3a9">boundingBox</a> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:ac6b304bd97447cbc99865cf2a8bdc3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07503961e01f5f633c9f1a371b36d780"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a07503961e01f5f633c9f1a371b36d780">boundingBox</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:a07503961e01f5f633c9f1a371b36d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125fdc1aa254554458167122ca14c08b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a125fdc1aa254554458167122ca14c08b">cubePlaneIntersectionAppend</a> (const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;plane, std::vector&lt; vec3 &gt; &amp;pos, std::vector&lt; std::uint32_t &gt; &amp;inds)</td></tr>
<tr class="separator:a125fdc1aa254554458167122ca14c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325313545a3da575e7d59610adc77b5"><td class="memItemLeft" align="right" valign="top"><a id="a8325313545a3da575e7d59610adc77b5" name="a8325313545a3da575e7d59610adc77b5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>cubePlaneInstersection</b> (const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;plane)</td></tr>
<tr class="separator:a8325313545a3da575e7d59610adc77b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memTemplParams" colspan="2"><a id="a2bfdf4a3d482622cdc4e0c93413d8882" name="a2bfdf4a3d482622cdc4e0c93413d8882"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMap</b> (T val, glm::vec&lt; 2, T &gt; from, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:a2bfdf4a3d482622cdc4e0c93413d8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619bd9b0b9e1ab9ea244ef9526cf27c3"><td class="memTemplParams" colspan="2"><a id="a619bd9b0b9e1ab9ea244ef9526cf27c3" name="a619bd9b0b9e1ab9ea244ef9526cf27c3"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a619bd9b0b9e1ab9ea244ef9526cf27c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMap</b> (glm::vec&lt; N, T &gt; val, glm::vec&lt; 2, T &gt; from, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:a619bd9b0b9e1ab9ea244ef9526cf27c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f266dd81c7151d6857b280e26562cf"><td class="memTemplParams" colspan="2"><a id="af4f266dd81c7151d6857b280e26562cf" name="af4f266dd81c7151d6857b280e26562cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4f266dd81c7151d6857b280e26562cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapToNormalized</b> (T val, glm::vec&lt; 2, T &gt; from) noexcept</td></tr>
<tr class="separator:af4f266dd81c7151d6857b280e26562cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a5b4e84c8cb6a539eedd20b49c70f"><td class="memTemplParams" colspan="2"><a id="ab40a5b4e84c8cb6a539eedd20b49c70f" name="ab40a5b4e84c8cb6a539eedd20b49c70f"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab40a5b4e84c8cb6a539eedd20b49c70f"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapToNormalized</b> (glm::vec&lt; N, T &gt; val, glm::vec&lt; 2, T &gt; from) noexcept</td></tr>
<tr class="separator:ab40a5b4e84c8cb6a539eedd20b49c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c3773b68b1e83ed4e34429afddf66"><td class="memTemplParams" colspan="2"><a id="ae05c3773b68b1e83ed4e34429afddf66" name="ae05c3773b68b1e83ed4e34429afddf66"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae05c3773b68b1e83ed4e34429afddf66"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapFromNormalized</b> (T val, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:ae05c3773b68b1e83ed4e34429afddf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081435ca0fcb35765e818bfb1166a78"><td class="memTemplParams" colspan="2"><a id="ac081435ca0fcb35765e818bfb1166a78" name="ac081435ca0fcb35765e818bfb1166a78"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ac081435ca0fcb35765e818bfb1166a78"><td class="memTemplItemLeft" align="right" valign="top">constexpr glm::vec&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearMapFromNormalized</b> (glm::vec&lt; N, T &gt; val, glm::vec&lt; 2, T &gt; to) noexcept</td></tr>
<tr class="separator:ac081435ca0fcb35765e818bfb1166a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7574c90a17ef8edcc49ddd56aa365"><td class="memTemplParams" colspan="2"><a id="a06b7574c90a17ef8edcc49ddd56aa365" name="a06b7574c90a17ef8edcc49ddd56aa365"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06b7574c90a17ef8edcc49ddd56aa365"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeVectorRange</b> (ptrdiff_t start, ptrdiff_t end, ptrdiff_t step=1)</td></tr>
<tr class="separator:a06b7574c90a17ef8edcc49ddd56aa365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a113ffe3c58862bd0eb9e4b47ba95b7"><td class="memTemplParams" colspan="2"><a id="a1a113ffe3c58862bd0eb9e4b47ba95b7" name="a1a113ffe3c58862bd0eb9e4b47ba95b7"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a1a113ffe3c58862bd0eb9e4b47ba95b7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Permutations</b> (util::span&lt; T, N &gt;, size_t) -&gt; <a class="el" href="classinviwo_1_1util_1_1Permutations.html">Permutations</a>&lt; T &gt;</td></tr>
<tr class="separator:a1a113ffe3c58862bd0eb9e4b47ba95b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee015aa37392cf43377c4dafc2d065d"><td class="memTemplParams" colspan="2"><a id="a9ee015aa37392cf43377c4dafc2d065d" name="a9ee015aa37392cf43377c4dafc2d065d"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9ee015aa37392cf43377c4dafc2d065d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Combinations</b> (util::span&lt; T, N &gt;, size_t) -&gt; <a class="el" href="classinviwo_1_1util_1_1Combinations.html">Combinations</a>&lt; T &gt;</td></tr>
<tr class="separator:a9ee015aa37392cf43377c4dafc2d065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d28c1699fb750c1f986df4603f0596"><td class="memTemplParams" colspan="2"><a id="a07d28c1699fb750c1f986df4603f0596" name="a07d28c1699fb750c1f986df4603f0596"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a07d28c1699fb750c1f986df4603f0596"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexProduct</b> (util::span&lt; T, N &gt;) -&gt; <a class="el" href="classinviwo_1_1util_1_1IndexProduct.html">IndexProduct</a>&lt; T &gt;</td></tr>
<tr class="separator:a07d28c1699fb750c1f986df4603f0596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba248938bdec0647ee6706ea2ece4c8c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aba248938bdec0647ee6706ea2ece4c8c">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *)</td></tr>
<tr class="separator:aba248938bdec0647ee6706ea2ece4c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608356f2ce89e1326c5ab6910337a907"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a608356f2ce89e1326c5ab6910337a907">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *)</td></tr>
<tr class="separator:a608356f2ce89e1326c5ab6910337a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baa816930736caaf0d8b9f4e0733723"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0baa816930736caaf0d8b9f4e0733723">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *)</td></tr>
<tr class="separator:a0baa816930736caaf0d8b9f4e0733723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab66fbd51685a6de63dfd0e06b89013"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6ab66fbd51685a6de63dfd0e06b89013">getInviwoApplication</a> (<a class="el" href="classinviwo_1_1Property.html">Property</a> *)</td></tr>
<tr class="separator:a6ab66fbd51685a6de63dfd0e06b89013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458419095875341f984870e6f8e9fd13"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a458419095875341f984870e6f8e9fd13">getInviwoApplication</a> ()</td></tr>
<tr class="separator:a458419095875341f984870e6f8e9fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cc48e4cef1ca0ef24a274fc8b444d9"><td class="memItemLeft" align="right" valign="top"><a id="a04cc48e4cef1ca0ef24a274fc8b444d9" name="a04cc48e4cef1ca0ef24a274fc8b444d9"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">IndexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeIndexBuffer</b> (std::vector&lt; std::uint32_t &gt; &amp;&amp;data)</td></tr>
<tr class="separator:a04cc48e4cef1ca0ef24a274fc8b444d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbce003fde844659f3fb7534b370d64c"><td class="memTemplParams" colspan="2"><a id="acbce003fde844659f3fb7534b370d64c" name="acbce003fde844659f3fb7534b370d64c"></a>
template&lt;typename T  = vec3, BufferUsage U = BufferUsage::Static, BufferTarget Target = BufferTarget::Data&gt; </td></tr>
<tr class="memitem:acbce003fde844659f3fb7534b370d64c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Buffer.html">Buffer</a>&lt; T, Target &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeBuffer</b> (std::vector&lt; T &gt; &amp;&amp;data)</td></tr>
<tr class="separator:acbce003fde844659f3fb7534b370d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37abc25e96c99f34aac8f37606c7df4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad37abc25e96c99f34aac8f37606c7df4">getCameraFovProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:ad37abc25e96c99f34aac8f37606c7df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertical fov property in the cameraProperty.  <a href="namespaceinviwo_1_1util.html#ad37abc25e96c99f34aac8f37606c7df4">More...</a><br /></td></tr>
<tr class="separator:ad37abc25e96c99f34aac8f37606c7df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1562123df97b5129796b73f231e1bd5"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad1562123df97b5129796b73f231e1bd5">createCameraFovProperty</a> (std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:ad1562123df97b5129796b73f231e1bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vertical fov property for use in a camera property.  <a href="namespaceinviwo_1_1util.html#ad1562123df97b5129796b73f231e1bd5">More...</a><br /></td></tr>
<tr class="separator:ad1562123df97b5129796b73f231e1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25faca6335f85635cde61c0986c2343"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa25faca6335f85635cde61c0986c2343">updateOrCreateCameraFovProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:aa25faca6335f85635cde61c0986c2343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing vertical fov property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <a href="namespaceinviwo_1_1util.html#aa25faca6335f85635cde61c0986c2343">More...</a><br /></td></tr>
<tr class="separator:aa25faca6335f85635cde61c0986c2343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfe78f266537021920d03efb74a15a3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8cfe78f266537021920d03efb74a15a3">getCameraWidthProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:a8cfe78f266537021920d03efb74a15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the width property in the cameraProperty.  <a href="namespaceinviwo_1_1util.html#a8cfe78f266537021920d03efb74a15a3">More...</a><br /></td></tr>
<tr class="separator:a8cfe78f266537021920d03efb74a15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd42ede5eb2f1d94c2405c9f36c005"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a53cd42ede5eb2f1d94c2405c9f36c005">createCameraWidthProperty</a> (std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:a53cd42ede5eb2f1d94c2405c9f36c005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a width property for use in a <a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a>.  <a href="namespaceinviwo_1_1util.html#a53cd42ede5eb2f1d94c2405c9f36c005">More...</a><br /></td></tr>
<tr class="separator:a53cd42ede5eb2f1d94c2405c9f36c005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27d645275cb437d22b94f20ddfe611a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab27d645275cb437d22b94f20ddfe611a">updateOrCreateCameraWidthProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; float()&gt; get, std::function&lt; void(const float &amp;)&gt; set)</td></tr>
<tr class="memdesc:ab27d645275cb437d22b94f20ddfe611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing width property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <a href="namespaceinviwo_1_1util.html#ab27d645275cb437d22b94f20ddfe611a">More...</a><br /></td></tr>
<tr class="separator:ab27d645275cb437d22b94f20ddfe611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae046e2b3232a4ce60452ccc5853efb9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aae046e2b3232a4ce60452ccc5853efb9">getCameraEyeOffsetProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty)</td></tr>
<tr class="memdesc:aae046e2b3232a4ce60452ccc5853efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eye offset property in the cameraProperty.  <a href="namespaceinviwo_1_1util.html#aae046e2b3232a4ce60452ccc5853efb9">More...</a><br /></td></tr>
<tr class="separator:aae046e2b3232a4ce60452ccc5853efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2a9a37232b9367cf8bc52093935b37"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5e2a9a37232b9367cf8bc52093935b37">createCameraEyeOffsetProperty</a> (std::function&lt; vec2()&gt; get, std::function&lt; void(const vec2 &amp;)&gt; set)</td></tr>
<tr class="memdesc:a5e2a9a37232b9367cf8bc52093935b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an eye offset property for use in a camera property.  <a href="namespaceinviwo_1_1util.html#a5e2a9a37232b9367cf8bc52093935b37">More...</a><br /></td></tr>
<tr class="separator:a5e2a9a37232b9367cf8bc52093935b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d38c8a311e159b1bdb778697984dbe"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa4d38c8a311e159b1bdb778697984dbe">updateOrCreateCameraEyeOffsetProperty</a> (<a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;cameraProperty, std::function&lt; vec2()&gt; get, std::function&lt; void(const vec2 &amp;)&gt; set)</td></tr>
<tr class="memdesc:aa4d38c8a311e159b1bdb778697984dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either return an existing eye offset property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property.  <a href="namespaceinviwo_1_1util.html#aa4d38c8a311e159b1bdb778697984dbe">More...</a><br /></td></tr>
<tr class="separator:aa4d38c8a311e159b1bdb778697984dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7430ed5a7df8b460b6fdae1d9778ed7"><td class="memItemLeft" align="right" valign="top"><a id="ab7430ed5a7df8b460b6fdae1d9778ed7" name="ab7430ed5a7df8b460b6fdae1d9778ed7"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>fovyToWidth</b> (float fovy, float distance, float aspect)</td></tr>
<tr class="separator:ab7430ed5a7df8b460b6fdae1d9778ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869aff7fa775da8d091ab53335f07de"><td class="memItemLeft" align="right" valign="top"><a id="ac869aff7fa775da8d091ab53335f07de" name="ac869aff7fa775da8d091ab53335f07de"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>widthToFovy</b> (float width, float distance, float aspect)</td></tr>
<tr class="separator:ac869aff7fa775da8d091ab53335f07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76223fb253c738efe53ef628360a54b"><td class="memItemLeft" align="right" valign="top"><a id="ad76223fb253c738efe53ef628360a54b" name="ad76223fb253c738efe53ef628360a54b"></a>
IVW_CORE_API float&#160;</td><td class="memItemRight" valign="bottom"><b>widthToViewDist</b> (float width, float fov, float aspect)</td></tr>
<tr class="separator:ad76223fb253c738efe53ef628360a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memTemplParams" colspan="2"><a id="a916efff8c0f4ed2fd1774e7aac8b9265" name="a916efff8c0f4ed2fd1774e7aac8b9265"></a>
template&lt;typename CamType &gt; </td></tr>
<tr class="memitem:a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memTemplItemLeft" align="right" valign="top">vec3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>perspectiveZoom</b> (CamType &amp;cam, float factor, std::optional&lt; mat4 &gt;)</td></tr>
<tr class="separator:a916efff8c0f4ed2fd1774e7aac8b9265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a4fe15a6ce4e2858ff3d7333515866"><td class="memItemLeft" align="right" valign="top"><a id="a17a4fe15a6ce4e2858ff3d7333515866" name="a17a4fe15a6ce4e2858ff3d7333515866"></a>
IVW_CORE_API uvec3&#160;</td><td class="memItemRight" valign="bottom"><b>getDataFormatColor</b> (NumericType t, size_t comp, size_t size)</td></tr>
<tr class="separator:a17a4fe15a6ce4e2858ff3d7333515866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8f37ab73d4d9bf20018bd26a64910"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a71d8f37ab73d4d9bf20018bd26a64910">appendIfNotEmpty</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:a71d8f37ab73d4d9bf20018bd26a64910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memTemplParams" colspan="2"><a id="aa6fd9efe91dbf2a0948f48cb2006efbe" name="aa6fd9efe91dbf2a0948f48cb2006efbe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>applySwizzleMask</b> (const glm::vec&lt; 4, T &gt; &amp;value, const SwizzleMask &amp;swizzlemask)</td></tr>
<tr class="separator:aa6fd9efe91dbf2a0948f48cb2006efbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459b9f2146938f3a148047c59ecb7af"><td class="memItemLeft" align="right" valign="top"><a id="a8459b9f2146938f3a148047c59ecb7af" name="a8459b9f2146938f3a148047c59ecb7af"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>registerCoreRepresentations</b> (<a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> &amp;obj)</td></tr>
<tr class="separator:a8459b9f2146938f3a148047c59ecb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342409a6d80362de7c0658f9a1a73a33"><td class="memItemLeft" align="right" valign="top"><a id="a342409a6d80362de7c0658f9a1a73a33" name="a342409a6d80362de7c0658f9a1a73a33"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>registerCoreRepresentations</b> (<a class="el" href="classinviwo_1_1RepresentationFactoryManager.html">RepresentationFactoryManager</a> &amp;obj)</td></tr>
<tr class="separator:a342409a6d80362de7c0658f9a1a73a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe00225936cd1b989a4f5eb6855e7c4"><td class="memItemLeft" align="right" valign="top"><a id="a3fe00225936cd1b989a4f5eb6855e7c4" name="a3fe00225936cd1b989a4f5eb6855e7c4"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>distributeAlphaEvenly</b> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a3fe00225936cd1b989a4f5eb6855e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa968168071463db242384b63a4d17702"><td class="memItemLeft" align="right" valign="top"><a id="aa968168071463db242384b63a4d17702" name="aa968168071463db242384b63a4d17702"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>distributePositionEvenly</b> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:aa968168071463db242384b63a4d17702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833fb2a28acd35e6be134baa81331fa"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad833fb2a28acd35e6be134baa81331fa">alignAlphaToMean</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:ad833fb2a28acd35e6be134baa81331fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92665c9b8c2cd085faf8e4b701edbdc7"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a92665c9b8c2cd085faf8e4b701edbdc7">alignAlphaToTop</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a92665c9b8c2cd085faf8e4b701edbdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f406a130b054515fd4dceb5b35b84ba"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2f406a130b054515fd4dceb5b35b84ba">alignAlphaToBottom</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a2f406a130b054515fd4dceb5b35b84ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd54c996575d2b47bea52c51ee3ec14"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6fd54c996575d2b47bea52c51ee3ec14">alignPositionToMean</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a6fd54c996575d2b47bea52c51ee3ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27792fd235656d42d7e286db7cdc4bd3"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a27792fd235656d42d7e286db7cdc4bd3">alignPositionToLeft</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a27792fd235656d42d7e286db7cdc4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886b02bc8bf08edc11981f255bdc9780"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a886b02bc8bf08edc11981f255bdc9780">alignPositionToRight</a> (std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; selection)</td></tr>
<tr class="separator:a886b02bc8bf08edc11981f255bdc9780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7669f35617341a0ec4465acb3a0b4a93"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a7669f35617341a0ec4465acb3a0b4a93">interpolateAlpha</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a7669f35617341a0ec4465acb3a0b4a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3c9707e78b11bc105e3b2614f1621"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a0cb3c9707e78b11bc105e3b2614f1621">flipPositions</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;selection)</td></tr>
<tr class="separator:a0cb3c9707e78b11bc105e3b2614f1621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7304908bd837dfaff011544e102fd7be"><td class="memTemplParams" colspan="2"><a id="a7304908bd837dfaff011544e102fd7be" name="a7304908bd837dfaff011544e102fd7be"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a7304908bd837dfaff011544e102fd7be"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structinviwo_1_1Axis.html">Axis</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultAxes</b> ()</td></tr>
<tr class="separator:a7304908bd837dfaff011544e102fd7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9501a7975eb778dadfdf84c36b2e42"><td class="memItemLeft" align="right" valign="top"><a id="a5a9501a7975eb778dadfdf84c36b2e42" name="a5a9501a7975eb778dadfdf84c36b2e42"></a>
IVW_CORE_API unitgroups::EnabledGroups&#160;</td><td class="memItemRight" valign="bottom"><b>getSystemUnitGroups</b> ()</td></tr>
<tr class="separator:a5a9501a7975eb778dadfdf84c36b2e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061d6f9bef87114a1d72695cb6c84a90"><td class="memItemLeft" align="right" valign="top"><a id="a061d6f9bef87114a1d72695cb6c84a90" name="a061d6f9bef87114a1d72695cb6c84a90"></a>
IVW_CORE_API std::unordered_map&lt; units::detail::unit_data, std::vector&lt; <a class="el" href="structinviwo_1_1UnitDesc.html">UnitDesc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getUnitGroupsFor</b> (Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups)</td></tr>
<tr class="separator:a061d6f9bef87114a1d72695cb6c84a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2934c7b85aa65ddcb66c9479835c9e"><td class="memItemLeft" align="right" valign="top"><a id="adb2934c7b85aa65ddcb66c9479835c9e" name="adb2934c7b85aa65ddcb66c9479835c9e"></a>
IVW_CORE_API std::pair&lt; double, std::vector&lt; std::tuple&lt; std::string_view, std::string_view, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findBestSetOfNamedUnits</b> (Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups, UseUnitPrefixes usesPrefixes)</td></tr>
<tr class="separator:adb2934c7b85aa65ddcb66c9479835c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108147afd8e9756d9268e33b47507ea"><td class="memItemLeft" align="right" valign="top"><a id="a4108147afd8e9756d9268e33b47507ea" name="a4108147afd8e9756d9268e33b47507ea"></a>
IVW_CORE_API std::back_insert_iterator&lt; fmt::memory_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>formatUnitTo</b> (std::back_insert_iterator&lt; fmt::memory_buffer &gt; it, Unit unit, const unitgroups::EnabledGroups &amp;enabledGroups, UseUnitPrefixes usesPrefixes)</td></tr>
<tr class="separator:a4108147afd8e9756d9268e33b47507ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18afcb89dd78c0d803b13b0715a01d8b"><td class="memTemplParams" colspan="2"><a id="a18afcb89dd78c0d803b13b0715a01d8b" name="a18afcb89dd78c0d803b13b0715a01d8b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a18afcb89dd78c0d803b13b0715a01d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>printEvent</b> (std::ostream &amp;os, const std::string &amp;event, Args... args)</td></tr>
<tr class="separator:a18afcb89dd78c0d803b13b0715a01d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f64d2ea24438b89925cbe43e579758"><td class="memItemLeft" align="right" valign="top"><a id="a42f64d2ea24438b89925cbe43e579758" name="a42f64d2ea24438b89925cbe43e579758"></a>
void IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>readBytesIntoBuffer</b> (std::string_view file, size_t offset, size_t bytes, bool littleEndian, size_t elementSize, void *dest)</td></tr>
<tr class="separator:a42f64d2ea24438b89925cbe43e579758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9514f43e3c6ac74e6bfd2fa4f2acec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e9514f43e3c6ac74e6bfd2fa4f2acec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4e9514f43e3c6ac74e6bfd2fa4f2acec">saveData</a> (const T &amp;data, std::string_view filePath, const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;extension, Overwrite overwrite)</td></tr>
<tr class="separator:a4e9514f43e3c6ac74e6bfd2fa4f2acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128732ec0a0dabddb2e4f0aca274edab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a128732ec0a0dabddb2e4f0aca274edab"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a128732ec0a0dabddb2e4f0aca274edab">saveData</a> (const T &amp;data, std::string_view path, std::string_view name, const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;extensions, Overwrite overwrite)</td></tr>
<tr class="separator:a128732ec0a0dabddb2e4f0aca274edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df53e2e5a9b37dadc48615243e7121"><td class="memItemLeft" align="right" valign="top"><a id="a02df53e2e5a9b37dadc48615243e7121" name="a02df53e2e5a9b37dadc48615243e7121"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer, std::string_view path, const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;extension=<a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a>())</td></tr>
<tr class="separator:a02df53e2e5a9b37dadc48615243e7121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2a60a6f5a408eb8a05f86cc2ddfef8"><td class="memItemLeft" align="right" valign="top"><a id="adf2a60a6f5a408eb8a05f86cc2ddfef8" name="adf2a60a6f5a408eb8a05f86cc2ddfef8"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveLayer</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:adf2a60a6f5a408eb8a05f86cc2ddfef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d242ceccd576433a16ba3fb49b9015"><td class="memItemLeft" align="right" valign="top"><a id="a81d242ceccd576433a16ba3fb49b9015" name="a81d242ceccd576433a16ba3fb49b9015"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renamePort</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Port.html">Port</a> *, std::string &gt; &gt; rules)</td></tr>
<tr class="separator:a81d242ceccd576433a16ba3fb49b9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd1dc9d1b5331c6283334deec1a213"><td class="memItemLeft" align="right" valign="top"><a id="a33cd1dc9d1b5331c6283334deec1a213" name="a33cd1dc9d1b5331c6283334deec1a213"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>renameProperty</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt; &gt; rules, std::string path=&quot;Properties&quot;)</td></tr>
<tr class="separator:a33cd1dc9d1b5331c6283334deec1a213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1c0cb22b88b98acda2e4675f9b3a1"><td class="memItemLeft" align="right" valign="top"><a id="ab2b1c0cb22b88b98acda2e4675f9b3a1" name="ab2b1c0cb22b88b98acda2e4675f9b3a1"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>changePropertyType</b> (<a class="el" href="classinviwo_1_1Deserializer.html">Deserializer</a> &amp;d, std::vector&lt; std::pair&lt; const <a class="el" href="classinviwo_1_1Property.html">Property</a> *, std::string &gt; &gt; rules)</td></tr>
<tr class="separator:ab2b1c0cb22b88b98acda2e4675f9b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88c92e2f718ec5c0b0d4d9e709aaefe"><td class="memItemLeft" align="right" valign="top"><a id="ab88c92e2f718ec5c0b0d4d9e709aaefe" name="ab88c92e2f718ec5c0b0d4d9e709aaefe"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ab88c92e2f718ec5c0b0d4d9e709aaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406093b30abbcc88760e117872fac31f"><td class="memItemLeft" align="right" valign="top"><a id="a406093b30abbcc88760e117872fac31f" name="a406093b30abbcc88760e117872fac31f"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a406093b30abbcc88760e117872fac31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4281907848129ace041135deee2e6"><td class="memItemLeft" align="right" valign="top"><a id="ac4a4281907848129ace041135deee2e6" name="ac4a4281907848129ace041135deee2e6"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPredecessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:ac4a4281907848129ace041135deee2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb8d1b84ba1196842c236e7e45b6cd9"><td class="memItemLeft" align="right" valign="top"><a id="a0bb8d1b84ba1196842c236e7e45b6cd9" name="a0bb8d1b84ba1196842c236e7e45b6cd9"></a>
IVW_CORE_API std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSuccessors</b> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a0bb8d1b84ba1196842c236e7e45b6cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memTemplParams" colspan="2"><a id="ab8265d9e0a2ad906d2ffb7d2671efc65" name="ab8265d9e0a2ad906d2ffb7d2671efc65"></a>
template&lt;TraversalDirection D, VisitPattern V, typename Func , typename Filter  = DefaultTraversalFilter&gt; </td></tr>
<tr class="memitem:ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>traverseNetwork</b> (std::unordered_set&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;state, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, Func f, Filter connectionFilter=<a class="el" href="structinviwo_1_1util_1_1DefaultTraversalFilter.html">DefaultTraversalFilter</a>{})</td></tr>
<tr class="separator:ab8265d9e0a2ad906d2ffb7d2671efc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a41b8c7fc838241322d10ec52760b4"><td class="memItemLeft" align="right" valign="top"><a id="aa5a41b8c7fc838241322d10ec52760b4" name="aa5a41b8c7fc838241322d10ec52760b4"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topologicalSortFiltered</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:aa5a41b8c7fc838241322d10ec52760b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b1f2a584ca159e869ee5666acef52"><td class="memItemLeft" align="right" valign="top"><a id="a049b1f2a584ca159e869ee5666acef52" name="a049b1f2a584ca159e869ee5666acef52"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topologicalSort</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a049b1f2a584ca159e869ee5666acef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad4b58375e9767217d380b694a0f008"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1ad4b58375e9767217d380b694a0f008">getPositions</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a1ad4b58375e9767217d380b694a0f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917b0dac4338ee41354df68a988d4bca"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a917b0dac4338ee41354df68a988d4bca">getPositions</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a917b0dac4338ee41354df68a988d4bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9814ba491ab54162a61144582fff0dbd"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9814ba491ab54162a61144582fff0dbd">getCenterPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a9814ba491ab54162a61144582fff0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930eff3a3f70e0c02c85a55c99c13166"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a930eff3a3f70e0c02c85a55c99c13166">getCenterPosition</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:a930eff3a3f70e0c02c85a55c99c13166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8256eb5b33cde59a3e0d832b0569d323"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8256eb5b33cde59a3e0d832b0569d323">getBoundingBox</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors)</td></tr>
<tr class="separator:a8256eb5b33cde59a3e0d832b0569d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9c4d7699d86580d306484f30f7110d"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ade9c4d7699d86580d306484f30f7110d">getBoundingBox</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network)</td></tr>
<tr class="separator:ade9c4d7699d86580d306484f30f7110d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341a5fe91b0d7f378da017b90eb3779"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1341a5fe91b0d7f378da017b90eb3779">offsetPosition</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors, ivec2 offset)</td></tr>
<tr class="separator:a1341a5fe91b0d7f378da017b90eb3779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fa91973f804cd02c1e28fb635202d1"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af6fa91973f804cd02c1e28fb635202d1">setSelected</a> (const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;processors, bool selected)</td></tr>
<tr class="separator:af6fa91973f804cd02c1e28fb635202d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6305e2eae1b769937adef2a2bd34432e"><td class="memItemLeft" align="right" valign="top"><a id="a6305e2eae1b769937adef2a2bd34432e" name="a6305e2eae1b769937adef2a2bd34432e"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>serializeSelected</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::ostream &amp;os, const std::string &amp;refPath)</td></tr>
<tr class="separator:a6305e2eae1b769937adef2a2bd34432e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ff9a99d14a7553a535c5b389b49ed2"><td class="memItemLeft" align="right" valign="top"><a id="a51ff9a99d14a7553a535c5b389b49ed2" name="a51ff9a99d14a7553a535c5b389b49ed2"></a>
IVW_CORE_API std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>appendDeserialized</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::istream &amp;is, const std::string &amp;refPath, <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app)</td></tr>
<tr class="separator:a51ff9a99d14a7553a535c5b389b49ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32bca9eb7b830e055fdbab2e9fe37e5"><td class="memItemLeft" align="right" valign="top"><a id="ab32bca9eb7b830e055fdbab2e9fe37e5" name="ab32bca9eb7b830e055fdbab2e9fe37e5"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>addProcessorOnConnection</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt; processor, <a class="el" href="classinviwo_1_1PortConnection.html">PortConnection</a> connection)</td></tr>
<tr class="separator:ab32bca9eb7b830e055fdbab2e9fe37e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a0d9c50dd7c3ddfc2fed071822ea64"><td class="memItemLeft" align="right" valign="top"><a id="ab0a0d9c50dd7c3ddfc2fed071822ea64" name="ab0a0d9c50dd7c3ddfc2fed071822ea64"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceProcessor</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> &gt; newProcessor, <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *oldProcessor)</td></tr>
<tr class="separator:ab0a0d9c50dd7c3ddfc2fed071822ea64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0053a26fe75452c169960116eed583"><td class="memItemLeft" align="right" valign="top"><a id="afb0053a26fe75452c169960116eed583" name="afb0053a26fe75452c169960116eed583"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>forEachWorkspaceInDirRecusive</b> (std::string_view path, std::function&lt; void(std::string_view)&gt; callback)</td></tr>
<tr class="separator:afb0053a26fe75452c169960116eed583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09543269cc6687ff784578bfa5e83555"><td class="memItemLeft" align="right" valign="top"><a id="a09543269cc6687ff784578bfa5e83555" name="a09543269cc6687ff784578bfa5e83555"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>updateWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, std::string_view path, DryRun dryRun)</td></tr>
<tr class="separator:a09543269cc6687ff784578bfa5e83555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65c61ea23f690d9992c222ef2da9396"><td class="memItemLeft" align="right" valign="top"><a id="af65c61ea23f690d9992c222ef2da9396" name="af65c61ea23f690d9992c222ef2da9396"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>updateExampleWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, DryRun dryRun)</td></tr>
<tr class="separator:af65c61ea23f690d9992c222ef2da9396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b966a9db3d6a0af68092372ce49d2a"><td class="memItemLeft" align="right" valign="top"><a id="ab3b966a9db3d6a0af68092372ce49d2a" name="ab3b966a9db3d6a0af68092372ce49d2a"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>updateRegressionWorkspaces</b> (<a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> *app, DryRun dryRun)</td></tr>
<tr class="separator:ab3b966a9db3d6a0af68092372ce49d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac526048b608d9c8b31251eb6d4c633e4"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ac526048b608d9c8b31251eb6d4c633e4">replaceSelectionWithCompositeProcessor</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;network)</td></tr>
<tr class="separator:ac526048b608d9c8b31251eb6d4c633e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89b716938f61f15132ae42d6d4a16b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4c89b716938f61f15132ae42d6d4a16b">expandCompositeProcessorIntoNetwork</a> (<a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;composite)</td></tr>
<tr class="separator:a4c89b716938f61f15132ae42d6d4a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae539abc6359b34c4a21ed1928c8f5500"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ae539abc6359b34c4a21ed1928c8f5500">exportAllFiles</a> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;network, std::string_view dir, std::string_view nameTemplate, const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;candidateExtensions, Overwrite overwrite)</td></tr>
<tr class="separator:ae539abc6359b34c4a21ed1928c8f5500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b08b9b06ff9618dc41000a24d590ecc"><td class="memItemLeft" align="right" valign="top"><a id="a3b08b9b06ff9618dc41000a24d590ecc" name="a3b08b9b06ff9618dc41000a24d590ecc"></a>
<a class="el" href="classinviwo_1_1Tags.html">Tags</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getPlatformTags</b> (const <a class="el" href="classinviwo_1_1Tags.html">Tags</a> &amp;t)</td></tr>
<tr class="separator:a3b08b9b06ff9618dc41000a24d590ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f0efd826c637426672e1c60dd26c52"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a72f0efd826c637426672e1c60dd26c52">getMetaData</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a72f0efd826c637426672e1c60dd26c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c8c14214ac56aeafc8d0165333c57"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af74c8c14214ac56aeafc8d0165333c57">getMetaData</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:af74c8c14214ac56aeafc8d0165333c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f521098da377963713d6db28a4d5f6e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API ivec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5f521098da377963713d6db28a4d5f6e">getPosition</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a5f521098da377963713d6db28a4d5f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164993d46bdb58f8b16a943c65ae4b9c"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a164993d46bdb58f8b16a943c65ae4b9c">setPosition</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, ivec2 pos)</td></tr>
<tr class="separator:a164993d46bdb58f8b16a943c65ae4b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33720f81ed26a3562c7447ce9eb89288"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a33720f81ed26a3562c7447ce9eb89288">isSelected</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor)</td></tr>
<tr class="separator:a33720f81ed26a3562c7447ce9eb89288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78172b271a10c03a2bb4a1a41bbde23e"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a78172b271a10c03a2bb4a1a41bbde23e">setSelected</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, bool selected)</td></tr>
<tr class="separator:a78172b271a10c03a2bb4a1a41bbde23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743b3fa3cbde44118de690fe87a21113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a743b3fa3cbde44118de690fe87a21113"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a743b3fa3cbde44118de690fe87a21113">makeProcessor</a> (ivec2 pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a743b3fa3cbde44118de690fe87a21113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b3a4cdb6bbdfa1398237053e844f65"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a97b3a4cdb6bbdfa1398237053e844f65">getProcessorModule</a> (const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *processor, const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:a97b3a4cdb6bbdfa1398237053e844f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which module that registered a processor.  <a href="namespaceinviwo_1_1util.html#a97b3a4cdb6bbdfa1398237053e844f65">More...</a><br /></td></tr>
<tr class="separator:a97b3a4cdb6bbdfa1398237053e844f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee3e86bf4e266b4a15880bf67c34d8a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4ee3e86bf4e266b4a15880bf67c34d8a">getProcessorModule</a> (std::string_view classIdentifier, const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:a4ee3e86bf4e266b4a15880bf67c34d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find which module that registered a processor.  <a href="namespaceinviwo_1_1util.html#a4ee3e86bf4e266b4a15880bf67c34d8a">More...</a><br /></td></tr>
<tr class="separator:a4ee3e86bf4e266b4a15880bf67c34d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb4e1d0a952f2a8216385f68ac32178"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a9bb4e1d0a952f2a8216385f68ac32178"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9bb4e1d0a952f2a8216385f68ac32178">trySetProperty</a> (<a class="el" href="classinviwo_1_1Processor.html">Processor</a> *proc, std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, V &amp;&amp;val, bool recursive=false)</td></tr>
<tr class="memdesc:a9bb4e1d0a952f2a8216385f68ac32178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set a processor's property to a given value.  <a href="namespaceinviwo_1_1util.html#a9bb4e1d0a952f2a8216385f68ac32178">More...</a><br /></td></tr>
<tr class="separator:a9bb4e1d0a952f2a8216385f68ac32178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d0fa4ad06fba067f12d5f75e38b715"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa3d0fa4ad06fba067f12d5f75e38b715">getProcessorModuleIdentifier</a> (std::string_view classIdentifier, const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;app)</td></tr>
<tr class="memdesc:aa3d0fa4ad06fba067f12d5f75e38b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the module identifier of a registered processor.  <a href="namespaceinviwo_1_1util.html#aa3d0fa4ad06fba067f12d5f75e38b715">More...</a><br /></td></tr>
<tr class="separator:aa3d0fa4ad06fba067f12d5f75e38b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3f90c8cfa64a0898b021cca551de05"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ada3f90c8cfa64a0898b021cca551de05">ordinalColor</a> (float r, float g, float b, float a=1.0f, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:ada3f90c8cfa64a0898b021cca551de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81edf9b276066462960fe0b021067ac9"><td class="memItemLeft" align="right" valign="top"><a id="a81edf9b276066462960fe0b021067ac9" name="a81edf9b276066462960fe0b021067ac9"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalColor</b> (const vec4 &amp;value, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a81edf9b276066462960fe0b021067ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ddfe5e9aca53b4bdeca169d9c94238"><td class="memItemLeft" align="right" valign="top"><a id="a26ddfe5e9aca53b4bdeca169d9c94238" name="a26ddfe5e9aca53b4bdeca169d9c94238"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalColor</b> (const vec3 &amp;value, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a26ddfe5e9aca53b4bdeca169d9c94238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad4ee6e4bff4e3a4c701bb0a2011c9"><td class="memItemLeft" align="right" valign="top"><a id="a68ad4ee6e4bff4e3a4c701bb0a2011c9" name="a68ad4ee6e4bff4e3a4c701bb0a2011c9"></a>
IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordinalLight</b> (const vec3 &amp;pos, float min=-100.0, float max=100.0, <a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a68ad4ee6e4bff4e3a4c701bb0a2011c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fe508315d93a69417c6ee9614303d6"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a78fe508315d93a69417c6ee9614303d6">ordinalRefColor</a> (<a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a> invalidationLevel=InvalidationLevel::InvalidOutput)</td></tr>
<tr class="separator:a78fe508315d93a69417c6ee9614303d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47927175e2344c3b515b14d86e5c508e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a47927175e2344c3b515b14d86e5c508e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a47927175e2344c3b515b14d86e5c508e">updateDefaultState</a> (T &amp;property, const U &amp;state, OverwriteState overwrite)</td></tr>
<tr class="separator:a47927175e2344c3b515b14d86e5c508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e2de815b4aaf7afb2f97ffb9f20681"><td class="memTemplParams" colspan="2"><a id="a59e2de815b4aaf7afb2f97ffb9f20681" name="a59e2de815b4aaf7afb2f97ffb9f20681"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a59e2de815b4aaf7afb2f97ffb9f20681"><td class="memTemplItemLeft" align="right" valign="top">util::span&lt; const std::string_view, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultValues</b> ()</td></tr>
<tr class="separator:a59e2de815b4aaf7afb2f97ffb9f20681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f02b27583f5e5189bf082ee8ec7ea"><td class="memItemLeft" align="right" valign="top"><a id="ab59f02b27583f5e5189bf082ee8ec7ea" name="ab59f02b27583f5e5189bf082ee8ec7ea"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>debugBreak</b> ()</td></tr>
<tr class="separator:ab59f02b27583f5e5189bf082ee8ec7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7add893c040adf20aa7bfb32b6aa7"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ac1a7add893c040adf20aa7bfb32b6aa7">reverse</a> (<a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;b)</td></tr>
<tr class="separator:ac1a7add893c040adf20aa7bfb32b6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770d8229540ecf6f0fd353141bae69cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a770d8229540ecf6f0fd353141bae69cd">getBuildInfo</a> ()</td></tr>
<tr class="memdesc:a770d8229540ecf6f0fd353141bae69cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses build information via an INI file or compile-time definitions.  <a href="namespaceinviwo_1_1util.html#a770d8229540ecf6f0fd353141bae69cd">More...</a><br /></td></tr>
<tr class="separator:a770d8229540ecf6f0fd353141bae69cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6454513ac3989576585452cfcc96ad32"><td class="memItemLeft" align="right" valign="top"><a id="a6454513ac3989576585452cfcc96ad32" name="a6454513ac3989576585452cfcc96ad32"></a>
constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_hash</b> (std::string_view str) noexcept</td></tr>
<tr class="separator:a6454513ac3989576585452cfcc96ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09726916a99e7ab3917ffb55d5155961"><td class="memTemplParams" colspan="2"><a id="a09726916a99e7ab3917ffb55d5155961" name="a09726916a99e7ab3917ffb55d5155961"></a>
template&lt;size_t len&gt; </td></tr>
<tr class="memitem:a09726916a99e7ab3917ffb55d5155961"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_hash</b> (const char(&amp;str)[len]) noexcept</td></tr>
<tr class="separator:a09726916a99e7ab3917ffb55d5155961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memTemplParams" colspan="2"><a id="aebfd07a246bca8b3fc3f3e243aaea23a" name="aebfd07a246bca8b3fc3f3e243aaea23a"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1HasEnumName.html">HasEnumName</a>&lt; T &gt;::value, std::size_t &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enumName</b> ()</td></tr>
<tr class="separator:aebfd07a246bca8b3fc3f3e243aaea23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aeb6b8dfc1fe3a44825c0a2dbbc2ae65a">forEach</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback)</td></tr>
<tr class="separator:aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5152f1acc0ccd5f17aef14a459df80b0"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback , typename OnDoneCallback &gt; </td></tr>
<tr class="memitem:a5152f1acc0ccd5f17aef14a459df80b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5152f1acc0ccd5f17aef14a459df80b0">forEachParallelAsync</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs, OnDoneCallback &amp;&amp;onTaskDone)</td></tr>
<tr class="separator:a5152f1acc0ccd5f17aef14a459df80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67d76735eef23f9b566af1e6cadeff4"><td class="memTemplParams" colspan="2"><a id="aa67d76735eef23f9b566af1e6cadeff4" name="aa67d76735eef23f9b566af1e6cadeff4"></a>
template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:aa67d76735eef23f9b566af1e6cadeff4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachParallelAsync</b> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs=0)</td></tr>
<tr class="separator:aa67d76735eef23f9b566af1e6cadeff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Callback &gt; </td></tr>
<tr class="memitem:adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#adc3ba8edf9868ee32bb79ba5f1c1b114">forEachParallel</a> (const Iterable &amp;iterable, Callback &amp;&amp;callback, size_t jobs=0)</td></tr>
<tr class="separator:adc3ba8edf9868ee32bb79ba5f1c1b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplParams" colspan="2"><a id="a32b94d32a4f96dd412446b35fa058db6" name="a32b94d32a4f96dd412446b35fa058db6"></a>
template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:a32b94d32a4f96dd412446b35fa058db6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_argument</b> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a32b94d32a4f96dd412446b35fa058db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368"><td class="memTemplParams" colspan="2"><a id="a259f343736e8083a8b38183038511368" name="a259f343736e8083a8b38183038511368"></a>
template&lt;typename F , typename TupleType &gt; </td></tr>
<tr class="memitem:a259f343736e8083a8b38183038511368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType &amp;&amp;t)</td></tr>
<tr class="separator:a259f343736e8083a8b38183038511368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplParams" colspan="2"><a id="a9bc3c6a37ecf5dc4e89d4a99bd930f53" name="a9bc3c6a37ecf5dc4e89d4a99bd930f53"></a>
template&lt;typename F , typename TupleType1 , typename TupleType2 &gt; </td></tr>
<tr class="memitem:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_in_tuple</b> (F &amp;&amp;f, TupleType1 &amp;&amp;t1, TupleType2 &amp;&amp;t2)</td></tr>
<tr class="separator:a9bc3c6a37ecf5dc4e89d4a99bd930f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca164bcff0db4b93cbc9de0eb812b2"><td class="memItemLeft" align="right" valign="top"><a id="a37ca164bcff0db4b93cbc9de0eb812b2" name="a37ca164bcff0db4b93cbc9de0eb812b2"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_kilobytes</b> (size_t bytes)</td></tr>
<tr class="separator:a37ca164bcff0db4b93cbc9de0eb812b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d30c3f086e87522149945a4ffe73745"><td class="memItemLeft" align="right" valign="top"><a id="a1d30c3f086e87522149945a4ffe73745" name="a1d30c3f086e87522149945a4ffe73745"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_to_megabytes</b> (size_t bytes)</td></tr>
<tr class="separator:a1d30c3f086e87522149945a4ffe73745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeca1d139ecb3cd31fc924e613bebc7"><td class="memItemLeft" align="right" valign="top"><a id="a4aeca1d139ecb3cd31fc924e613bebc7" name="a4aeca1d139ecb3cd31fc924e613bebc7"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kilobytes_to_bytes</b> (size_t bytes)</td></tr>
<tr class="separator:a4aeca1d139ecb3cd31fc924e613bebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b4ec57df08fccd6dbeb93edd64614a"><td class="memItemLeft" align="right" valign="top"><a id="ae1b4ec57df08fccd6dbeb93edd64614a" name="ae1b4ec57df08fccd6dbeb93edd64614a"></a>
IVW_CORE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>megabytes_to_bytes</b> (size_t bytes)</td></tr>
<tr class="separator:ae1b4ec57df08fccd6dbeb93edd64614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0faf2bd22d3779355b4b8db67f3915"><td class="memItemLeft" align="right" valign="top"><a id="aed0faf2bd22d3779355b4b8db67f3915" name="aed0faf2bd22d3779355b4b8db67f3915"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatBytesToString</b> (size_t bytes)</td></tr>
<tr class="separator:aed0faf2bd22d3779355b4b8db67f3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplParams" colspan="2"><a id="acf3e029c8ccf362d845dfa9362adada1" name="acf3e029c8ccf362d845dfa9362adada1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf3e029c8ccf362d845dfa9362adada1"><td class="memTemplItemLeft" align="right" valign="top">constexpr NumericType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getNumericType</b> ()</td></tr>
<tr class="separator:acf3e029c8ccf362d845dfa9362adada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplParams" colspan="2"><a id="a5780feabad27a979c9c92bc67cf6ada2" name="a5780feabad27a979c9c92bc67cf6ada2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5780feabad27a979c9c92bc67cf6ada2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const T &amp;v)</td></tr>
<tr class="separator:a5780feabad27a979c9c92bc67cf6ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46823dad226364774c3e7f3b30ca21e9"><td class="memTemplParams" colspan="2"><a id="a46823dad226364774c3e7f3b30ca21e9" name="a46823dad226364774c3e7f3b30ca21e9"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:a46823dad226364774c3e7f3b30ca21e9"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:a46823dad226364774c3e7f3b30ca21e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616f1e85d565c9149aba9f87a798f09"><td class="memItemLeft" align="right" valign="top"><a id="af616f1e85d565c9149aba9f87a798f09" name="af616f1e85d565c9149aba9f87a798f09"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af616f1e85d565c9149aba9f87a798f09"><td class="memTemplItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:af616f1e85d565c9149aba9f87a798f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplParams" colspan="2"><a id="a47fc3d300d9eae79274e06a2ea8a5325" name="a47fc3d300d9eae79274e06a2ea8a5325"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const T &amp;v)</td></tr>
<tr class="separator:a47fc3d300d9eae79274e06a2ea8a5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c6a37fda50958cd9ff741f12929524"><td class="memTemplParams" colspan="2"><a id="a31c6a37fda50958cd9ff741f12929524" name="a31c6a37fda50958cd9ff741f12929524"></a>
template&lt;glm::length_t L, typename T , glm::qualifier Q&gt; </td></tr>
<tr class="memitem:a31c6a37fda50958cd9ff741f12929524"><td class="memTemplItemLeft" align="right" valign="top">glm::vec&lt; L, bool, Q &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const glm::vec&lt; L, T, Q &gt; &amp;x)</td></tr>
<tr class="separator:a31c6a37fda50958cd9ff741f12929524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d1d573292f23607b2c2415d52c916"><td class="memItemLeft" align="right" valign="top"><a id="a7e9d1d573292f23607b2c2415d52c916" name="a7e9d1d573292f23607b2c2415d52c916"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e9d1d573292f23607b2c2415d52c916"><td class="memTemplItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isnan</b> (const half_float::half &amp;v)</td></tr>
<tr class="separator:a7e9d1d573292f23607b2c2415d52c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290"><td class="memTemplParams" colspan="2"><a id="a95fab874f7e075134d5dba1055797290" name="a95fab874f7e075134d5dba1055797290"></a>
template&lt;class U , class T , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a95fab874f7e075134d5dba1055797290"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (T x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a95fab874f7e075134d5dba1055797290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae934ab3f6de2848e5e2967ce21234162"><td class="memTemplParams" colspan="2"><a id="ae934ab3f6de2848e5e2967ce21234162" name="ae934ab3f6de2848e5e2967ce21234162"></a>
template&lt;glm::length_t L, class U , glm::qualifier Q, template&lt; glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:ae934ab3f6de2848e5e2967ce21234162"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; L, U, Q &gt; &gt;::value==1, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (vecType&lt; L, U, Q &gt; const &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:ae934ab3f6de2848e5e2967ce21234162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e477e9ceeb2d5892fb009d824aa9cbf"><td class="memTemplParams" colspan="2"><a id="a2e477e9ceeb2d5892fb009d824aa9cbf" name="a2e477e9ceeb2d5892fb009d824aa9cbf"></a>
template&lt;glm::length_t C, glm::length_t R, class U , glm::qualifier Q, template&lt; glm::length_t, glm::length_t, typename, glm::qualifier &gt; class vecType, class BinaryOperation &gt; </td></tr>
<tr class="memitem:a2e477e9ceeb2d5892fb009d824aa9cbf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; vecType&lt; C, R, U, Q &gt; &gt;::value==2, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>accumulate</b> (vecType&lt; C, R, U, Q &gt; const &amp;x, U init, BinaryOperation op)</td></tr>
<tr class="separator:a2e477e9ceeb2d5892fb009d824aa9cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eff460b2d764066b797ef27c597841b"><td class="memTemplParams" colspan="2"><a id="a3eff460b2d764066b797ef27c597841b" name="a3eff460b2d764066b797ef27c597841b"></a>
template&lt;typename To  = double, typename From , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; From &gt;::value==0 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; To &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3eff460b2d764066b797ef27c597841b"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert</b> (From x)</td></tr>
<tr class="separator:a3eff460b2d764066b797ef27c597841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02025471c09a9e5870cd267aff10a109"><td class="memTemplParams" colspan="2"><a id="a02025471c09a9e5870cd267aff10a109" name="a02025471c09a9e5870cd267aff10a109"></a>
template&lt;typename To  = double, typename From , typename std::enable_if&lt; std::is_same&lt; To, From &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a02025471c09a9e5870cd267aff10a109"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm_convert_normalized</b> (From x)</td></tr>
<tr class="separator:a02025471c09a9e5870cd267aff10a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplParams" colspan="2"><a id="ad141644d95fac699b26e542dd8e9a06a" name="ad141644d95fac699b26e542dd8e9a06a"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad141644d95fac699b26e542dd8e9a06a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t) -&gt; T &amp;</td></tr>
<tr class="separator:ad141644d95fac699b26e542dd8e9a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplParams" colspan="2"><a id="a0e69e5cb6a27439895b97689f5f3f2ed" name="a0e69e5cb6a27439895b97689f5f3f2ed"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a0e69e5cb6a27439895b97689f5f3f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c813b4a28f97e89951e116d28a6664"><td class="memTemplParams" colspan="2"><a id="a43c813b4a28f97e89951e116d28a6664" name="a43c813b4a28f97e89951e116d28a6664"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==0, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a43c813b4a28f97e89951e116d28a6664"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (T &amp;elem, size_t, size_t) -&gt; T &amp;</td></tr>
<tr class="separator:a43c813b4a28f97e89951e116d28a6664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplParams" colspan="2"><a id="a05c3d34285fc06bf52759afd757fb61f" name="a05c3d34285fc06bf52759afd757fb61f"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a05c3d34285fc06bf52759afd757fb61f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glmcomp</b> (const T &amp;elem, size_t i, size_t j) -&gt; const typename T::value_type &amp;</td></tr>
<tr class="separator:a05c3d34285fc06bf52759afd757fb61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplParams" colspan="2"><a id="a325d0254070f7fb9aec6ff895d4a0bdc" name="a325d0254070f7fb9aec6ff895d4a0bdc"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memTemplItemLeft" align="right" valign="top">Type1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invertY</b> (Type1 vec, Type2 dim)</td></tr>
<tr class="separator:a325d0254070f7fb9aec6ff895d4a0bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f"><td class="memTemplParams" colspan="2"><a id="afca39adef75ff36c5b3846a86e67269f" name="afca39adef75ff36c5b3846a86e67269f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca39adef75ff36c5b3846a86e67269f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const T &amp;t)</td></tr>
<tr class="separator:afca39adef75ff36c5b3846a86e67269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memItemLeft" align="right" valign="top"><a id="a45a5e593ad97ae54ea8fe10fb4e88e2f" name="a45a5e593ad97ae54ea8fe10fb4e88e2f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all</b> (const bool &amp;t)</td></tr>
<tr class="separator:a45a5e593ad97ae54ea8fe10fb4e88e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplParams" colspan="2"><a id="a1fe8554ac4434ebd0a96ebc1427b44b0" name="a1fe8554ac4434ebd0a96ebc1427b44b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const T &amp;t)</td></tr>
<tr class="separator:a1fe8554ac4434ebd0a96ebc1427b44b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memItemLeft" align="right" valign="top"><a id="a7ee2ac139048aa0bc7f4d823ba6c26a4" name="a7ee2ac139048aa0bc7f4d823ba6c26a4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any</b> (const bool &amp;t)</td></tr>
<tr class="separator:a7ee2ac139048aa0bc7f4d823ba6c26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b594a5638571d9e20783d8843f3c38"><td class="memTemplParams" colspan="2">template&lt;typename M , typename T  = typename M::value_type&gt; </td></tr>
<tr class="memitem:ad2b594a5638571d9e20783d8843f3c38"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad2b594a5638571d9e20783d8843f3c38">filled</a> (T v)</td></tr>
<tr class="separator:ad2b594a5638571d9e20783d8843f3c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39455e5bf0802a86ac661f5cd43a2c96"><td class="memTemplParams" colspan="2"><a id="a39455e5bf0802a86ac661f5cd43a2c96" name="a39455e5bf0802a86ac661f5cd43a2c96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39455e5bf0802a86ac661f5cd43a2c96"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>epsilon</b> ()</td></tr>
<tr class="separator:a39455e5bf0802a86ac661f5cd43a2c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5743b44930aa236ce672a2a8d90075b5"><td class="memTemplParams" colspan="2"><a id="a5743b44930aa236ce672a2a8d90075b5" name="a5743b44930aa236ce672a2a8d90075b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5743b44930aa236ce672a2a8d90075b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>almostEqual</b> (const T &amp;x, const T &amp;y, int ulp=2)</td></tr>
<tr class="separator:a5743b44930aa236ce672a2a8d90075b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ca9372bd3a12d9a2579ac7c99c890"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a903ca9372bd3a12d9a2579ac7c99c890"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a903ca9372bd3a12d9a2579ac7c99c890">hash_combine</a> (std::size_t &amp;seed, const T &amp;v) noexcept</td></tr>
<tr class="separator:a903ca9372bd3a12d9a2579ac7c99c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memTemplParams" colspan="2"><a id="afa0e9ce120322b1c4a80d7b5a15dda1f" name="afa0e9ce120322b1c4a80d7b5a15dda1f"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixel</b> (const size2_t dims, C callback)</td></tr>
<tr class="separator:afa0e9ce120322b1c4a80d7b5a15dda1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplParams" colspan="2"><a id="adf8843b349d3a16c4bc14bb9f2604229" name="adf8843b349d3a16c4bc14bb9f2604229"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:adf8843b349d3a16c4bc14bb9f2604229"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback)</td></tr>
<tr class="separator:adf8843b349d3a16c4bc14bb9f2604229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memTemplParams" colspan="2"><a id="aacf7f75ddf74603a9c1d22f1dd14f06f" name="aacf7f75ddf74603a9c1d22f1dd14f06f"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixelParallel</b> (const size2_t dims, C callback, size_t jobs=0)</td></tr>
<tr class="separator:aacf7f75ddf74603a9c1d22f1dd14f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplParams" colspan="2"><a id="afed8f6b8d9311afc3ee6ee2f112b3e5b" name="afed8f6b8d9311afc3ee6ee2f112b3e5b"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachPixelParallel</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &amp;layer, C callback, size_t jobs=0)</td></tr>
<tr class="separator:afed8f6b8d9311afc3ee6ee2f112b3e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f5062b65dcfe3b90585892491ae766"><td class="memItemLeft" align="right" valign="top"><a id="aa6f5062b65dcfe3b90585892491ae766" name="aa6f5062b65dcfe3b90585892491ae766"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipLayerVertical</b> (<a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:aa6f5062b65dcfe3b90585892491ae766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bbe63ea03b1e65d776a1ec7e01e2c1"><td class="memItemLeft" align="right" valign="top"><a id="af1bbe63ea03b1e65d776a1ec7e01e2c1" name="af1bbe63ea03b1e65d776a1ec7e01e2c1"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipLayerHorizontal</b> (<a class="el" href="classinviwo_1_1Layer.html">Layer</a> &amp;layer)</td></tr>
<tr class="separator:af1bbe63ea03b1e65d776a1ec7e01e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f880ffbf2501e300a9ad61c94bdc13e"><td class="memItemLeft" align="right" valign="top"><a id="a4f880ffbf2501e300a9ad61c94bdc13e" name="a4f880ffbf2501e300a9ad61c94bdc13e"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipImageVertical</b> (<a class="el" href="classinviwo_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:a4f880ffbf2501e300a9ad61c94bdc13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50f0d2c5925c59ac8a1ba911492586c"><td class="memItemLeft" align="right" valign="top"><a id="af50f0d2c5925c59ac8a1ba911492586c" name="af50f0d2c5925c59ac8a1ba911492586c"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>flipImageHorizontal</b> (<a class="el" href="classinviwo_1_1Image.html">Image</a> &amp;img)</td></tr>
<tr class="separator:af50f0d2c5925c59ac8a1ba911492586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc379ba38f17b9b6764e03c78aaa6eb1"><td class="memItemLeft" align="right" valign="top"><a id="acc379ba38f17b9b6764e03c78aaa6eb1" name="acc379ba38f17b9b6764e03c78aaa6eb1"></a>
IVW_CORE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readImageFromDisk</b> (std::string filename)</td></tr>
<tr class="separator:acc379ba38f17b9b6764e03c78aaa6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841"><td class="memTemplParams" colspan="2"><a id="af246294ce0a3b7487f492874591b7841" name="af246294ce0a3b7487f492874591b7841"></a>
template&lt;size_t N, typename IndexType  = size_t&gt; </td></tr>
<tr class="memitem:af246294ce0a3b7487f492874591b7841"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeIndexMapper</b> (const Vector&lt; N, IndexType &gt; &amp;dim)</td></tr>
<tr class="separator:af246294ce0a3b7487f492874591b7841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf61d0ad31846cd5659939c933633ff"><td class="memTemplParams" colspan="2">template&lt;bool PropagateConst = true, typename Iter &gt; </td></tr>
<tr class="memitem:a8bf61d0ad31846cd5659939c933633ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt; Iter, PropagateConst &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a8bf61d0ad31846cd5659939c933633ff">makeIndirectIterator</a> (Iter &amp;&amp;iter)</td></tr>
<tr class="separator:a8bf61d0ad31846cd5659939c933633ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f14f5355cd5f4226b2ed543111a88a5"><td class="memTemplParams" colspan="2"><a id="a6f14f5355cd5f4226b2ed543111a88a5" name="a6f14f5355cd5f4226b2ed543111a88a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f14f5355cd5f4226b2ed543111a88a5"><td class="memTemplItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>classIdentifier</b> ()</td></tr>
<tr class="separator:a6f14f5355cd5f4226b2ed543111a88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memTemplParams" colspan="2"><a id="aee2d0b4fcb0533981da56e4e1dfdf8db" name="aee2d0b4fcb0533981da56e4e1dfdf8db"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memTemplItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataName</b> ()</td></tr>
<tr class="separator:aee2d0b4fcb0533981da56e4e1dfdf8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43295d437e6b3ac2ddf5953617696232"><td class="memTemplParams" colspan="2"><a id="a43295d437e6b3ac2ddf5953617696232" name="a43295d437e6b3ac2ddf5953617696232"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43295d437e6b3ac2ddf5953617696232"><td class="memTemplItemLeft" align="right" valign="top">uvec3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>colorCode</b> ()</td></tr>
<tr class="separator:a43295d437e6b3ac2ddf5953617696232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c8d9edb1b87b683609454a60e7dde"><td class="memTemplParams" colspan="2"><a id="aef0c8d9edb1b87b683609454a60e7dde" name="aef0c8d9edb1b87b683609454a60e7dde"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef0c8d9edb1b87b683609454a60e7dde"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_info</b> (const T *data)</td></tr>
<tr class="separator:aef0c8d9edb1b87b683609454a60e7dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea670d98ef52707b5b30f1a36b333da"><td class="memTemplParams" colspan="2"><a id="abea670d98ef52707b5b30f1a36b333da" name="abea670d98ef52707b5b30f1a36b333da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abea670d98ef52707b5b30f1a36b333da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1Document.html">Document</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>info</b> (const T &amp;data)</td></tr>
<tr class="separator:abea670d98ef52707b5b30f1a36b333da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969a21a4a5700b83983fd809c3a644a7"><td class="memItemLeft" align="right" valign="top"><a id="a969a21a4a5700b83983fd809c3a644a7" name="a969a21a4a5700b83983fd809c3a644a7"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (<a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context, std::string_view message, LogLevel level=LogLevel::Info, LogAudience audience=LogAudience::Developer)</td></tr>
<tr class="separator:a969a21a4a5700b83983fd809c3a644a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9c8ecb238bf5f82d5929d6e01db80d"><td class="memItemLeft" align="right" valign="top"><a id="add9c8ecb238bf5f82d5929d6e01db80d" name="add9c8ecb238bf5f82d5929d6e01db80d"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (<a class="el" href="classinviwo_1_1Logger.html">Logger</a> *logger, <a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context, std::string_view message, LogLevel level=LogLevel::Info, LogAudience audience=LogAudience::Developer)</td></tr>
<tr class="separator:add9c8ecb238bf5f82d5929d6e01db80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memTemplParams" colspan="2"><a id="afa0fd3611aa8a9a7c2e3dbf98335146c" name="afa0fd3611aa8a9a7c2e3dbf98335146c"></a>
template&lt;class charT , class traits , class DelimT &gt; </td></tr>
<tr class="memitem:afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinviwo_1_1util_1_1ostream__joiner.html">ostream_joiner</a>&lt; std::decay_t&lt; DelimT &gt;, charT, traits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_ostream_joiner</b> (std::basic_ostream&lt; charT, traits &gt; &amp;os, DelimT &amp;&amp;delimiter)</td></tr>
<tr class="separator:afa0fd3611aa8a9a7c2e3dbf98335146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplParams" colspan="2"><a id="a7515b33c203ea126830f4bb9238bcaf1" name="a7515b33c203ea126830f4bb9238bcaf1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7515b33c203ea126830f4bb9238bcaf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetValue</b> (T &amp;t, T value)</td></tr>
<tr class="separator:a7515b33c203ea126830f4bb9238bcaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplParams" colspan="2"><a id="af71ef5ebf3e6127ca2a819ef1ed62926" name="af71ef5ebf3e6127ca2a819ef1ed62926"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memTemplItemLeft" align="right" valign="top">OnScopeExit::ExitAction&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RevertValue</b> (T &amp;t)</td></tr>
<tr class="separator:af71ef5ebf3e6127ca2a819ef1ed62926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9922dfbd31bfe3e88cb73d3807f80f"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ace9922dfbd31bfe3e88cb73d3807f80f">getLibrarySearchPaths</a> ()</td></tr>
<tr class="memdesc:ace9922dfbd31bfe3e88cb73d3807f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib".  <a href="namespaceinviwo_1_1util.html#ace9922dfbd31bfe3e88cb73d3807f80f">More...</a><br /></td></tr>
<tr class="separator:ace9922dfbd31bfe3e88cb73d3807f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a65c662f716e8cf323f7dfed82a9e93"><td class="memItemLeft" align="right" valign="top"><a id="a4a65c662f716e8cf323f7dfed82a9e93" name="a4a65c662f716e8cf323f7dfed82a9e93"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAddLibrarySearchDirsFunction</b> ()</td></tr>
<tr class="separator:a4a65c662f716e8cf323f7dfed82a9e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa979449bc62d88018601d58c494c5997"><td class="memItemLeft" align="right" valign="top"><a id="aa979449bc62d88018601d58c494c5997" name="aa979449bc62d88018601d58c494c5997"></a>
IVW_CORE_API std::vector&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>addLibrarySearchDirs</b> (const std::vector&lt; std::string &gt; &amp;dirs)</td></tr>
<tr class="separator:aa979449bc62d88018601d58c494c5997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d11fef30175f6774fa9cf51f0b0e1c"><td class="memItemLeft" align="right" valign="top"><a id="a31d11fef30175f6774fa9cf51f0b0e1c" name="a31d11fef30175f6774fa9cf51f0b0e1c"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>removeLibrarySearchDirs</b> (const std::vector&lt; void * &gt; &amp;dirs)</td></tr>
<tr class="separator:a31d11fef30175f6774fa9cf51f0b0e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a78b45e1072066ebf1f2d1a47c20fc"><td class="memItemLeft" align="right" valign="top"><a id="a19a78b45e1072066ebf1f2d1a47c20fc" name="a19a78b45e1072066ebf1f2d1a47c20fc"></a>
IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLoadedLibraries</b> ()</td></tr>
<tr class="separator:a19a78b45e1072066ebf1f2d1a47c20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7027c33c0e5cca77f766e2adffbc159"><td class="memTemplParams" colspan="2"><a id="ab7027c33c0e5cca77f766e2adffbc159" name="ab7027c33c0e5cca77f766e2adffbc159"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ab7027c33c0e5cca77f766e2adffbc159"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab7027c33c0e5cca77f766e2adffbc159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03d708b62027089f9e07139d40e498d"><td class="memTemplParams" colspan="2"><a id="aa03d708b62027089f9e07139d40e498d" name="aa03d708b62027089f9e07139d40e498d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa03d708b62027089f9e07139d40e498d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (std::size_t n)</td></tr>
<tr class="separator:aa03d708b62027089f9e07139d40e498d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4805855bc6f8370faf1d0a4fcba862b"><td class="memTemplParams" colspan="2"><a id="aa4805855bc6f8370faf1d0a4fcba862b" name="aa4805855bc6f8370faf1d0a4fcba862b"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:aa4805855bc6f8370faf1d0a4fcba862b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:aa4805855bc6f8370faf1d0a4fcba862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aee9509dafb895ed476086c7842d34"><td class="memTemplParams" colspan="2"><a id="a10aee9509dafb895ed476086c7842d34" name="a10aee9509dafb895ed476086c7842d34"></a>
template&lt;typename Derived , typename Base , typename Del &gt; </td></tr>
<tr class="memitem:a10aee9509dafb895ed476086c7842d34"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived, Del &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, Del &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a10aee9509dafb895ed476086c7842d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6b59173be1397d3042c99557326482"><td class="memTemplParams" colspan="2"><a id="a3a6b59173be1397d3042c99557326482" name="a3a6b59173be1397d3042c99557326482"></a>
template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:a3a6b59173be1397d3042c99557326482"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_unique_ptr_cast</b> (std::unique_ptr&lt; Base, std::default_delete&lt; Base &gt; &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a3a6b59173be1397d3042c99557326482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memTemplParams" colspan="2"><a id="a4c7408d8a59968f771b7ad3dc0c75f28" name="a4c7408d8a59968f771b7ad3dc0c75f28"></a>
template&lt;std::size_t N, typename Index  = size_t, typename Functor &gt; </td></tr>
<tr class="memitem:a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_array</b> (Functor &amp;&amp;func) noexcept -&gt; std::array&lt; decltype(func(std::declval&lt; Index &gt;())), N &gt;</td></tr>
<tr class="separator:a4c7408d8a59968f771b7ad3dc0c75f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8b12fa242507b1725c301a4ef5714e"><td class="memTemplParams" colspan="2"><a id="a2e8b12fa242507b1725c301a4ef5714e" name="a2e8b12fa242507b1725c301a4ef5714e"></a>
template&lt;typename Common , typename... Ts&gt; </td></tr>
<tr class="memitem:a2e8b12fa242507b1725c301a4ef5714e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ref</b> (Ts &amp;... args)</td></tr>
<tr class="separator:a2e8b12fa242507b1725c301a4ef5714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d"><td class="memTemplParams" colspan="2"><a id="a90888f794252ba3891f368137a67369d" name="a90888f794252ba3891f368137a67369d"></a>
template&lt;typename T , typename std::enable_if&lt;!std::is_abstract&lt; T &gt;::value &amp;&amp;std::is_default_constructible&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a90888f794252ba3891f368137a67369d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>defaultConstructType</b> ()</td></tr>
<tr class="separator:a90888f794252ba3891f368137a67369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memTemplParams" colspan="2"><a id="a8b52a4904b65ef59d70ebf2b2b0ad7b0" name="a8b52a4904b65ef59d70ebf2b2b0ad7b0"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overloaded</b> (Ts...) -&gt; <a class="el" href="structinviwo_1_1util_1_1overloaded.html">overloaded</a>&lt; Ts... &gt;</td></tr>
<tr class="separator:a8b52a4904b65ef59d70ebf2b2b0ad7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplParams" colspan="2"><a id="abf81e9808c5ba9826b5771e2542490bf" name="abf81e9808c5ba9826b5771e2542490bf"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abf81e9808c5ba9826b5771e2542490bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove</b> (T &amp;cont, const V &amp;elem) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:abf81e9808c5ba9826b5771e2542490bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f"><td class="memTemplParams" colspan="2"><a id="af5262199109900b1b041fd1bb14a585f" name="af5262199109900b1b041fd1bb14a585f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:af5262199109900b1b041fd1bb14a585f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_remove_if</b> (T &amp;cont, Pred pred) -&gt; decltype(std::distance(std::declval&lt; T &gt;().begin(), std::declval&lt; T &gt;().end()))</td></tr>
<tr class="separator:af5262199109900b1b041fd1bb14a585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplParams" colspan="2"><a id="a2212b8323ef0cad0985bb8032a8c3e32" name="a2212b8323ef0cad0985bb8032a8c3e32"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase</b> (T &amp;cont)</td></tr>
<tr class="separator:a2212b8323ef0cad0985bb8032a8c3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplParams" colspan="2"><a id="a81d14f127305d858d416c2fdb0c4ec0f" name="a81d14f127305d858d416c2fdb0c4ec0f"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_erase_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a81d14f127305d858d416c2fdb0c4ec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38"><td class="memTemplParams" colspan="2"><a id="a5439e115005151ce337820ffa1246e38" name="a5439e115005151ce337820ffa1246e38"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a5439e115005151ce337820ffa1246e38"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_erase_remove_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a5439e115005151ce337820ffa1246e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplParams" colspan="2"><a id="a4ba2e79134e4bf5de2c2851f3ddbabb1" name="a4ba2e79134e4bf5de2c2851f3ddbabb1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_back_unique</b> (T &amp;cont, typename T::value_type elem)</td></tr>
<tr class="separator:a4ba2e79134e4bf5de2c2851f3ddbabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea31612c6c30e23896ee3f18ee729c66"><td class="memTemplParams" colspan="2"><a id="aea31612c6c30e23896ee3f18ee729c66" name="aea31612c6c30e23896ee3f18ee729c66"></a>
template&lt;typename Dst , typename... Srcs&gt; </td></tr>
<tr class="memitem:aea31612c6c30e23896ee3f18ee729c66"><td class="memTemplItemLeft" align="right" valign="top">Dst &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (Dst &amp;dest, Srcs &amp;&amp;... sources)</td></tr>
<tr class="separator:aea31612c6c30e23896ee3f18ee729c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272"><td class="memTemplParams" colspan="2"><a id="ac3403811241ba0b1d202ae0548baa272" name="ac3403811241ba0b1d202ae0548baa272"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ac3403811241ba0b1d202ae0548baa272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ac3403811241ba0b1d202ae0548baa272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5"><td class="memTemplParams" colspan="2"><a id="a6cb1874215836798aa939a09ea7097e5" name="a6cb1874215836798aa939a09ea7097e5"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a6cb1874215836798aa939a09ea7097e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (T &amp;cont, Pred pred) -&gt; typename T::iterator</td></tr>
<tr class="separator:a6cb1874215836798aa939a09ea7097e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplParams" colspan="2"><a id="ae8e5dd33fbb9abc8d28e1e74f78233e0" name="ae8e5dd33fbb9abc8d28e1e74f78233e0"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (const T &amp;cont, Pred pred) -&gt; typename T::const_iterator</td></tr>
<tr class="separator:ae8e5dd33fbb9abc8d28e1e74f78233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0"><td class="memTemplParams" colspan="2"><a id="ade96273c6f72f177a872f872e22091c0" name="ade96273c6f72f177a872f872e22091c0"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ade96273c6f72f177a872f872e22091c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ade96273c6f72f177a872f872e22091c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346"><td class="memTemplParams" colspan="2"><a id="ab1f54391ec0db5815036c778ed412346" name="ab1f54391ec0db5815036c778ed412346"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:ab1f54391ec0db5815036c778ed412346"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (T &amp;cont, Pred pred)</td></tr>
<tr class="separator:ab1f54391ec0db5815036c778ed412346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06"><td class="memTemplParams" colspan="2"><a id="ae770415d5ba00c86cf182d333590ac06" name="ae770415d5ba00c86cf182d333590ac06"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ae770415d5ba00c86cf182d333590ac06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const T &amp;cont, const V &amp;elem)</td></tr>
<tr class="separator:ae770415d5ba00c86cf182d333590ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplParams" colspan="2"><a id="a959a93edbea65cb8ae18addd0dcc04b1" name="a959a93edbea65cb8ae18addd0dcc04b1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_if</b> (const T &amp;cont, Pred pred)</td></tr>
<tr class="separator:a959a93edbea65cb8ae18addd0dcc04b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplParams" colspan="2"><a id="a071781f9ac07a9a1b432fc2aec6388ee" name="a071781f9ac07a9a1b432fc2aec6388ee"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if_or_null</b> (T &amp;cont, P pred) -&gt; typename T::value_type</td></tr>
<tr class="separator:a071781f9ac07a9a1b432fc2aec6388ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplParams" colspan="2"><a id="a49d7b74f00e72f7b4556af25b050a092" name="a49d7b74f00e72f7b4556af25b050a092"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a49d7b74f00e72f7b4556af25b050a092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::value_type</td></tr>
<tr class="separator:a49d7b74f00e72f7b4556af25b050a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplParams" colspan="2"><a id="ad093bf8f1f594c0f814c6154fb59e39c" name="ad093bf8f1f594c0f814c6154fb59e39c"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename T::value_type</td></tr>
<tr class="separator:ad093bf8f1f594c0f814c6154fb59e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplParams" colspan="2"><a id="a111c6325641f7d9c5bf18a934e5290c7" name="a111c6325641f7d9c5bf18a934e5290c7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a111c6325641f7d9c5bf18a934e5290c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_key</b> (T &amp;map, const typename T::key_type &amp;key)</td></tr>
<tr class="separator:a111c6325641f7d9c5bf18a934e5290c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplParams" colspan="2"><a id="a1ee41d732a5626da3a086161c7d83c33" name="a1ee41d732a5626da3a086161c7d83c33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ee41d732a5626da3a086161c7d83c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_unique</b> (T &amp;map, const typename T::key_type &amp;key, typename T::mapped_type &amp;value)</td></tr>
<tr class="separator:a1ee41d732a5626da3a086161c7d83c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplParams" colspan="2"><a id="a8d1bd66e291bc8e17a45faf11b8587bb" name="a8d1bd66e291bc8e17a45faf11b8587bb"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem) -&gt; typename T::mapped_type</td></tr>
<tr class="separator:a8d1bd66e291bc8e17a45faf11b8587bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memTemplParams" colspan="2"><a id="a27fa3775ce29cc54f0b8e740e72ac67e" name="a27fa3775ce29cc54f0b8e740e72ac67e"></a>
template&lt;typename T , typename V , typename Callable &gt; </td></tr>
<tr class="memitem:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_find_or_null</b> (T &amp;cont, const V &amp;elem, Callable f) -&gt; typename std::result_of&lt; Callable(typename T::mapped_type)&gt;::type</td></tr>
<tr class="separator:a27fa3775ce29cc54f0b8e740e72ac67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19583b6a36283c058dd0dbc54373094f"><td class="memTemplParams" colspan="2"><a id="a19583b6a36283c058dd0dbc54373094f" name="a19583b6a36283c058dd0dbc54373094f"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a19583b6a36283c058dd0dbc54373094f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:a19583b6a36283c058dd0dbc54373094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee64649b8ea8ed565e9597534fce8326"><td class="memTemplParams" colspan="2"><a id="aee64649b8ea8ed565e9597534fce8326" name="aee64649b8ea8ed565e9597534fce8326"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aee64649b8ea8ed565e9597534fce8326"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:aee64649b8ea8ed565e9597534fce8326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memTemplParams" colspan="2"><a id="a1caa4c49d2b4045a2ec2a28ee9be815a" name="a1caa4c49d2b4045a2ec2a28ee9be815a"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:a1caa4c49d2b4045a2ec2a28ee9be815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58a2f08d57fc0419b60673c3f62469"><td class="memTemplParams" colspan="2"><a id="acc58a2f08d57fc0419b60673c3f62469" name="acc58a2f08d57fc0419b60673c3f62469"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:acc58a2f08d57fc0419b60673c3f62469"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:acc58a2f08d57fc0419b60673c3f62469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85268c5944ad9fd579980101fa02bcd"><td class="memTemplParams" colspan="2"><a id="ac85268c5944ad9fd579980101fa02bcd" name="ac85268c5944ad9fd579980101fa02bcd"></a>
template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac85268c5944ad9fd579980101fa02bcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (InputIter begin, InputIter end, UnaryPredicate pred)</td></tr>
<tr class="separator:ac85268c5944ad9fd579980101fa02bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f62920005713409e889688968eb74"><td class="memTemplParams" colspan="2"><a id="a778f62920005713409e889688968eb74" name="a778f62920005713409e889688968eb74"></a>
template&lt;typename T , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a778f62920005713409e889688968eb74"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>none_of</b> (const T &amp;cont, UnaryPredicate pred)</td></tr>
<tr class="separator:a778f62920005713409e889688968eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47943383fe847434783771ad699cbb7"><td class="memTemplParams" colspan="2"><a id="ae47943383fe847434783771ad699cbb7" name="ae47943383fe847434783771ad699cbb7"></a>
template&lt;typename Iter , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ae47943383fe847434783771ad699cbb7"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_not_equal</b> (Iter begin, Iter end, Proj proj={})</td></tr>
<tr class="separator:ae47943383fe847434783771ad699cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f91d2006f1843504325bd721bbe515d"><td class="memTemplParams" colspan="2"><a id="a5f91d2006f1843504325bd721bbe515d" name="a5f91d2006f1843504325bd721bbe515d"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a5f91d2006f1843504325bd721bbe515d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Iter begin, Iter end)</td></tr>
<tr class="separator:a5f91d2006f1843504325bd721bbe515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7bbfcbfd1f31c50e554f0867860c79"><td class="memTemplParams" colspan="2"><a id="aff7bbfcbfd1f31c50e554f0867860c79" name="aff7bbfcbfd1f31c50e554f0867860c79"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aff7bbfcbfd1f31c50e554f0867860c79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (std::pair&lt; Iter, Iter &gt; const &amp;x)</td></tr>
<tr class="separator:aff7bbfcbfd1f31c50e554f0867860c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memTemplParams" colspan="2"><a id="a073bf64ff0dacce0c04d82ad13ff7cd9" name="a073bf64ff0dacce0c04d82ad13ff7cd9"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (Container &amp;c)</td></tr>
<tr class="separator:a073bf64ff0dacce0c04d82ad13ff7cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memTemplParams" colspan="2"><a id="a01b35cf2b4ff3575e9e49a95b9a3226e" name="a01b35cf2b4ff3575e9e49a95b9a3226e"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinviwo_1_1util_1_1iter__range.html">iter_range</a>&lt; typename Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_range</b> (const Container &amp;c)</td></tr>
<tr class="separator:a01b35cf2b4ff3575e9e49a95b9a3226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplParams" colspan="2"><a id="a9ea3b690dfcdeda7ee4c0a5c54926945" name="a9ea3b690dfcdeda7ee4c0a5c54926945"></a>
template&lt;typename T , typename OutIt , typename P &gt; </td></tr>
<tr class="memitem:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memTemplItemLeft" align="right" valign="top">OutIt&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, OutIt out, P pred)</td></tr>
<tr class="separator:a9ea3b690dfcdeda7ee4c0a5c54926945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplParams" colspan="2"><a id="a72545927f4c67d0c29ddf1fab7768ad8" name="a72545927f4c67d0c29ddf1fab7768ad8"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_if</b> (const T &amp;cont, P pred) -&gt; std::vector&lt; typename T::value_type &gt;</td></tr>
<tr class="separator:a72545927f4c67d0c29ddf1fab7768ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef553126a137991f8617700fe144f6"><td class="memTemplParams" colspan="2"><a id="a23ef553126a137991f8617700fe144f6" name="a23ef553126a137991f8617700fe144f6"></a>
template&lt;typename T , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a23ef553126a137991f8617700fe144f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (const T &amp;cont, UnaryOperation op) -&gt; std::vector&lt; std::invoke_result_t&lt; UnaryOperation, const typename T::value_type &gt; &gt;</td></tr>
<tr class="separator:a23ef553126a137991f8617700fe144f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1"><td class="memTemplParams" colspan="2"><a id="a8002915caf2929e669c07a259ff36fb1" name="a8002915caf2929e669c07a259ff36fb1"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a8002915caf2929e669c07a259ff36fb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont, Pred pred) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:a8002915caf2929e669c07a259ff36fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplParams" colspan="2"><a id="aa4401cb675aec808de01a4e7a9f552f1" name="aa4401cb675aec808de01a4e7a9f552f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4401cb675aec808de01a4e7a9f552f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordering</b> (T &amp;cont) -&gt; std::vector&lt; size_t &gt;</td></tr>
<tr class="separator:aa4401cb675aec808de01a4e7a9f552f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625"><td class="memTemplParams" colspan="2"><a id="aa7679ac4f77483edefc2dc236495b625" name="aa7679ac4f77483edefc2dc236495b625"></a>
template&lt;typename Generator &gt; </td></tr>
<tr class="memitem:aa7679ac4f77483edefc2dc236495b625"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>table</b> (Generator gen, int start, int end, int step=1) -&gt; std::vector&lt; decltype(gen(std::declval&lt; int &gt;()))&gt;</td></tr>
<tr class="separator:aa7679ac4f77483edefc2dc236495b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplParams" colspan="2"><a id="acdd7c9fa30cdd956764cfe090ff6a4bb" name="acdd7c9fa30cdd956764cfe090ff6a4bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_future_ready</b> (const std::future&lt; T &gt; &amp;future)</td></tr>
<tr class="separator:acdd7c9fa30cdd956764cfe090ff6a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255656e04e9caab0092cefb2387b522c"><td class="memTemplParams" colspan="2">template&lt;class T , typename Tuple , size_t count = 0&gt; </td></tr>
<tr class="memitem:a255656e04e9caab0092cefb2387b522c"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a255656e04e9caab0092cefb2387b522c">index_of</a> ()</td></tr>
<tr class="separator:a255656e04e9caab0092cefb2387b522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ffacb1ddf668f23cac00ffca4071a"><td class="memTemplParams" colspan="2">template&lt;class T , typename Tuple , size_t count = 0&gt; </td></tr>
<tr class="memitem:a144ffacb1ddf668f23cac00ffca4071a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a144ffacb1ddf668f23cac00ffca4071a">index_of_derived</a> ()</td></tr>
<tr class="separator:a144ffacb1ddf668f23cac00ffca4071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac562f60680204dda73a7d29d9c9ddb24"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ac562f60680204dda73a7d29d9c9ddb24">toWstring</a> (std::string_view str)</td></tr>
<tr class="memdesc:ac562f60680204dda73a7d29d9c9ddb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used.  <a href="namespaceinviwo_1_1util.html#ac562f60680204dda73a7d29d9c9ddb24">More...</a><br /></td></tr>
<tr class="separator:ac562f60680204dda73a7d29d9c9ddb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec5e6658368eb78ce7b3161c63eddb"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a53ec5e6658368eb78ce7b3161c63eddb">fromWstring</a> (std::wstring_view str)</td></tr>
<tr class="memdesc:a53ec5e6658368eb78ce7b3161c63eddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the given std::wstring to std::string. On Windows, WideCharToMultiByte is used for this conversion assuming utf8 encoding. Otherwise, std::wcsrtombs is used.  <a href="namespaceinviwo_1_1util.html#a53ec5e6658368eb78ce7b3161c63eddb">More...</a><br /></td></tr>
<tr class="separator:a53ec5e6658368eb78ce7b3161c63eddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040967fe9b1828c138864fcff6d60c0d"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a040967fe9b1828c138864fcff6d60c0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a040967fe9b1828c138864fcff6d60c0d">forEachStringPart</a> (std::string_view str, std::string_view sep, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a040967fe9b1828c138864fcff6d60c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on each part of the string after splitting by sep.  <a href="namespaceinviwo_1_1util.html#a040967fe9b1828c138864fcff6d60c0d">More...</a><br /></td></tr>
<tr class="separator:a040967fe9b1828c138864fcff6d60c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a68531c2a1a0d7b50fbcd32b4ab6d03a2">splitByFirst</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the first instance of a delimiter.  <a href="namespaceinviwo_1_1util.html#a68531c2a1a0d7b50fbcd32b4ab6d03a2">More...</a><br /></td></tr>
<tr class="separator:a68531c2a1a0d7b50fbcd32b4ab6d03a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e4709f37d1f58ead6f6bb699964102"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a72e4709f37d1f58ead6f6bb699964102">splitByFirst</a> (std::string_view str, std::string_view delimiter)</td></tr>
<tr class="memdesc:a72e4709f37d1f58ead6f6bb699964102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the first instance of a delimiter.  <a href="namespaceinviwo_1_1util.html#a72e4709f37d1f58ead6f6bb699964102">More...</a><br /></td></tr>
<tr class="separator:a72e4709f37d1f58ead6f6bb699964102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062e820ba75f7fb44e8b149e52dd979"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a7062e820ba75f7fb44e8b149e52dd979">splitByLast</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a7062e820ba75f7fb44e8b149e52dd979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the last instance of a delimiter.  <a href="namespaceinviwo_1_1util.html#a7062e820ba75f7fb44e8b149e52dd979">More...</a><br /></td></tr>
<tr class="separator:a7062e820ba75f7fb44e8b149e52dd979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22420f375af97c3654f65bd70c7df79c"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a22420f375af97c3654f65bd70c7df79c">splitByLast</a> (std::string_view str, std::string_view delimiter)</td></tr>
<tr class="memdesc:a22420f375af97c3654f65bd70c7df79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a string into two parts by the last instance of a delimiter.  <a href="namespaceinviwo_1_1util.html#a22420f375af97c3654f65bd70c7df79c">More...</a><br /></td></tr>
<tr class="separator:a22420f375af97c3654f65bd70c7df79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab608fdeb665bcddf5e9821006487364b"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab608fdeb665bcddf5e9821006487364b">splitString</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:ab608fdeb665bcddf5e9821006487364b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb.  <a href="namespaceinviwo_1_1util.html#ab608fdeb665bcddf5e9821006487364b">More...</a><br /></td></tr>
<tr class="separator:ab608fdeb665bcddf5e9821006487364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c12bda5703660547faff1bd31b8b9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a018c12bda5703660547faff1bd31b8b9">splitStringView</a> (std::string_view str, char delimiter=' ')</td></tr>
<tr class="memdesc:a018c12bda5703660547faff1bd31b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb.  <a href="namespaceinviwo_1_1util.html#a018c12bda5703660547faff1bd31b8b9">More...</a><br /></td></tr>
<tr class="separator:a018c12bda5703660547faff1bd31b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3562b94700f15c08e99b826745258a"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aeb3562b94700f15c08e99b826745258a">trim</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:aeb3562b94700f15c08e99b826745258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">trims <code>str</code> from beginning and end by removing white spaces  <a href="namespaceinviwo_1_1util.html#aeb3562b94700f15c08e99b826745258a">More...</a><br /></td></tr>
<tr class="separator:aeb3562b94700f15c08e99b826745258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72163c26b092ba2ad01a8ba8af763d59"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a72163c26b092ba2ad01a8ba8af763d59">iCaseEndsWith</a> (std::string_view str, std::string_view suffix)</td></tr>
<tr class="memdesc:a72163c26b092ba2ad01a8ba8af763d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if provided string ends with suffix using case insensitive equal comparison.  <a href="namespaceinviwo_1_1util.html#a72163c26b092ba2ad01a8ba8af763d59">More...</a><br /></td></tr>
<tr class="separator:a72163c26b092ba2ad01a8ba8af763d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b234248fa0f75afa5d053118ec319a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa0b234248fa0f75afa5d053118ec319a">elideLines</a> (std::string_view str, std::string_view abbrev=&quot;...&quot;, size_t maxLineLength=500)</td></tr>
<tr class="memdesc:aa0b234248fa0f75afa5d053118ec319a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elide parts of lines in <code>str</code> which are longer than <code>maxLineLength</code> and append <code>abbrev</code> instead.  <a href="namespaceinviwo_1_1util.html#aa0b234248fa0f75afa5d053118ec319a">More...</a><br /></td></tr>
<tr class="separator:aa0b234248fa0f75afa5d053118ec319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5fdac75f1e887548cfb8c9c22c37a1"><td class="memItemLeft" align="right" valign="top"><a id="a8b5fdac75f1e887548cfb8c9c22c37a1" name="a8b5fdac75f1e887548cfb8c9c22c37a1"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>setThreadDescription</b> (std::thread &amp;thread, const std::string &amp;desc)</td></tr>
<tr class="separator:a8b5fdac75f1e887548cfb8c9c22c37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2b2443c5b46240122de8b5dd5b400"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a86d2b2443c5b46240122de8b5dd5b400">getDefaultTimerThread</a> ()</td></tr>
<tr class="separator:a86d2b2443c5b46240122de8b5dd5b400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5d945da868ca74124adefa308b6188"><td class="memTemplParams" colspan="2"><a id="a8d5d945da868ca74124adefa308b6188" name="a8d5d945da868ca74124adefa308b6188"></a>
template&lt;typename <a class="el" href="classinviwo_1_1Transform.html">Transform</a> , typename Iter &gt; </td></tr>
<tr class="memitem:a8d5d945da868ca74124adefa308b6188"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTransformIterator</b> (<a class="el" href="classinviwo_1_1Transform.html">Transform</a> &amp;&amp;transform, Iter iter)</td></tr>
<tr class="separator:a8d5d945da868ca74124adefa308b6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9043d4a86a79be19df535ce9731f0153"><td class="memTemplParams" colspan="2">template&lt;typename... A, typename F &gt; </td></tr>
<tr class="memitem:a9043d4a86a79be19df535ce9731f0153"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a9043d4a86a79be19df535ce9731f0153">is_callable_with</a> (F &amp;&amp;)</td></tr>
<tr class="separator:a9043d4a86a79be19df535ce9731f0153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a0ae0e3b7f2982ed95511e8fd53ac"><td class="memItemLeft" align="right" valign="top"><a id="a8f3a0ae0e3b7f2982ed95511e8fd53ac" name="a8f3a0ae0e3b7f2982ed95511e8fd53ac"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveNetwork</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::string_view filename)</td></tr>
<tr class="separator:a8f3a0ae0e3b7f2982ed95511e8fd53ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ad36cf2b38fd0c3d8c6b3c7f56dd25"><td class="memItemLeft" align="right" valign="top"><a id="a84ad36cf2b38fd0c3d8c6b3c7f56dd25" name="a84ad36cf2b38fd0c3d8c6b3c7f56dd25"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>saveAllCanvases</b> (<a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *network, std::string_view dir, std::string_view name=&quot;UPN&quot;, std::string_view ext=&quot;.png&quot;, bool onlyActiveCanvases=false)</td></tr>
<tr class="separator:a84ad36cf2b38fd0c3d8c6b3c7f56dd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40eb018880e2f5c6f66452163325611"><td class="memItemLeft" align="right" valign="top"><a id="aa40eb018880e2f5c6f66452163325611" name="aa40eb018880e2f5c6f66452163325611"></a>
IVW_CORE_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidIdentifierCharacter</b> (char c, std::string_view extra=&quot;&quot;)</td></tr>
<tr class="separator:aa40eb018880e2f5c6f66452163325611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdddf35ec4d15a23cbfd492fca94050"><td class="memItemLeft" align="right" valign="top"><a id="a0fdddf35ec4d15a23cbfd492fca94050" name="a0fdddf35ec4d15a23cbfd492fca94050"></a>
IVW_CORE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>validateIdentifier</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::string_view type, <a class="el" href="classinviwo_1_1SourceContext.html">ExceptionContext</a> context, std::string_view extra=&quot;&quot;)</td></tr>
<tr class="separator:a0fdddf35ec4d15a23cbfd492fca94050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1641752b9b6ec1384f983f1f7b86a9"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2a1641752b9b6ec1384f983f1f7b86a9">findUniqueIdentifier</a> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::function&lt; bool(std::string_view)&gt; isUnique, std::string_view sep=&quot; &quot;)</td></tr>
<tr class="separator:a2a1641752b9b6ec1384f983f1f7b86a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287fded47920b2a0e2dada11249da84"><td class="memItemLeft" align="right" valign="top"><a id="a9287fded47920b2a0e2dada11249da84" name="a9287fded47920b2a0e2dada11249da84"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>cleanIdentifier</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>, std::string_view extra=&quot;&quot;)</td></tr>
<tr class="separator:a9287fded47920b2a0e2dada11249da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c62a1beeaef244810ed786c86d2074"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a35c62a1beeaef244810ed786c86d2074">stripModuleFileNameDecoration</a> (std::string_view filePath)</td></tr>
<tr class="memdesc:a35c62a1beeaef244810ed786c86d2074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found.  <a href="namespaceinviwo_1_1util.html#a35c62a1beeaef244810ed786c86d2074">More...</a><br /></td></tr>
<tr class="separator:a35c62a1beeaef244810ed786c86d2074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96dd02792cfa20cef05e9d001b497b"><td class="memItemLeft" align="right" valign="top"><a id="a7a96dd02792cfa20cef05e9d001b497b" name="a7a96dd02792cfa20cef05e9d001b497b"></a>
IVW_CORE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stripIdentifier</b> (std::string_view <a class="el" href="structinviwo_1_1util_1_1identifier.html">identifier</a>)</td></tr>
<tr class="separator:a7a96dd02792cfa20cef05e9d001b497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplParams" colspan="2"><a id="a08654e337b9b5894672a1b218f5b9a31" name="a08654e337b9b5894672a1b218f5b9a31"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a08654e337b9b5894672a1b218f5b9a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>show</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a08654e337b9b5894672a1b218f5b9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11"><td class="memTemplParams" colspan="2"><a id="a84700445b4e279e926156e7539163a11" name="a84700445b4e279e926156e7539163a11"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a84700445b4e279e926156e7539163a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hide</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a84700445b4e279e926156e7539163a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437319dfe415d9e61f70fd1e4bc7981"><td class="memTemplParams" colspan="2"><a id="a7437319dfe415d9e61f70fd1e4bc7981" name="a7437319dfe415d9e61f70fd1e4bc7981"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7437319dfe415d9e61f70fd1e4bc7981"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxel</b> (const size3_t dims, C callback)</td></tr>
<tr class="separator:a7437319dfe415d9e61f70fd1e4bc7981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplParams" colspan="2"><a id="ad6d5b4f91c4ac3ca3d914354878b1601" name="ad6d5b4f91c4ac3ca3d914354878b1601"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback)</td></tr>
<tr class="separator:ad6d5b4f91c4ac3ca3d914354878b1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddb074a2060ace9bb2c3e1700eb0159"><td class="memTemplParams" colspan="2"><a id="afddb074a2060ace9bb2c3e1700eb0159" name="afddb074a2060ace9bb2c3e1700eb0159"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afddb074a2060ace9bb2c3e1700eb0159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxelParallel</b> (const size3_t dims, C callback, size_t jobs=0)</td></tr>
<tr class="separator:afddb074a2060ace9bb2c3e1700eb0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplParams" colspan="2"><a id="a13d81aad86b9c7cb3348b7e57305d8a2" name="a13d81aad86b9c7cb3348b7e57305d8a2"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forEachVoxelParallel</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &amp;v, C callback, size_t jobs=0)</td></tr>
<tr class="separator:a13d81aad86b9c7cb3348b7e57305d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f12474688f04b692773ec8860ed48c"><td class="memItemLeft" align="right" valign="top"><a id="a55f12474688f04b692773ec8860ed48c" name="a55f12474688f04b692773ec8860ed48c"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamps</b> (const VolumeSequence &amp;seq, bool checkfirstonly=true)</td></tr>
<tr class="separator:a55f12474688f04b692773ec8860ed48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4859a20f2976466da44f190a9f8ac4ef"><td class="memItemLeft" align="right" valign="top"><a id="a4859a20f2976466da44f190a9f8ac4ef" name="a4859a20f2976466da44f190a9f8ac4ef"></a>
std::pair&lt; double, double &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestampRange</b> (const VolumeSequence &amp;seq, bool sorted=true)</td></tr>
<tr class="separator:a4859a20f2976466da44f190a9f8ac4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66305155d49b83d83a0ed4bc53577f"><td class="memItemLeft" align="right" valign="top"><a id="a4a66305155d49b83d83a0ed4bc53577f" name="a4a66305155d49b83d83a0ed4bc53577f"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>isSorted</b> (const VolumeSequence &amp;seq)</td></tr>
<tr class="separator:a4a66305155d49b83d83a0ed4bc53577f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba6db9dcbcedd225e39d3363c37ff72"><td class="memItemLeft" align="right" valign="top"><a id="acba6db9dcbcedd225e39d3363c37ff72" name="acba6db9dcbcedd225e39d3363c37ff72"></a>
VolumeSequence IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>sortSequence</b> (const VolumeSequence &amp;seq)</td></tr>
<tr class="separator:acba6db9dcbcedd225e39d3363c37ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6501f84e5e57a74c849922e5dbfa803"><td class="memItemLeft" align="right" valign="top"><a id="ab6501f84e5e57a74c849922e5dbfa803" name="ab6501f84e5e57a74c849922e5dbfa803"></a>
std::pair&lt; SharedVolume, SharedVolume &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getVolumesForTimestep</b> (const VolumeSequence &amp;seq, double t, bool sorted=true)</td></tr>
<tr class="separator:ab6501f84e5e57a74c849922e5dbfa803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa096e06503a48a699ed30fb098da24f6"><td class="memItemLeft" align="right" valign="top"><a id="aa096e06503a48a699ed30fb098da24f6" name="aa096e06503a48a699ed30fb098da24f6"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasTimestamp</b> (SharedVolume vol)</td></tr>
<tr class="separator:aa096e06503a48a699ed30fb098da24f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a8a5714927959fd8a7962a2f6be6f"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a8a5714927959fd8a7962a2f6be6f" name="a0d2a8a5714927959fd8a7962a2f6be6f"></a>
double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getTimestamp</b> (SharedVolume vol)</td></tr>
<tr class="separator:a0d2a8a5714927959fd8a7962a2f6be6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6fe2283af95ca86e331a61dba4d69"><td class="memItemLeft" align="right" valign="top"><a id="af4f6fe2283af95ca86e331a61dba4d69" name="af4f6fe2283af95ca86e331a61dba4d69"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>hasMargins</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:af4f6fe2283af95ca86e331a61dba4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0ff59bd90d37ed4d9bef5a3f6295e2"><td class="memItemLeft" align="right" valign="top"><a id="a3b0ff59bd90d37ed4d9bef5a3f6295e2" name="a3b0ff59bd90d37ed4d9bef5a3f6295e2"></a>
bool IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>isBricked</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a3b0ff59bd90d37ed4d9bef5a3f6295e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97bfd32f7b2c3dcbb9e6e288fa4b4b9"><td class="memItemLeft" align="right" valign="top"><a id="af97bfd32f7b2c3dcbb9e6e288fa4b4b9" name="af97bfd32f7b2c3dcbb9e6e288fa4b4b9"></a>
size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><b>getBrickDimensions</b> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:af97bfd32f7b2c3dcbb9e6e288fa4b4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694731debfdf03c3fe12fd45f760e22"><td class="memItemLeft" align="right" valign="top">std::pair&lt; vec3, vec3 &gt; IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2694731debfdf03c3fe12fd45f760e22">getVolumeMargins</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:a2694731debfdf03c3fe12fd45f760e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the margins of a volume, in normalized texture coordinates [0,1]  <a href="namespaceinviwo_1_1util.html#a2694731debfdf03c3fe12fd45f760e22">More...</a><br /></td></tr>
<tr class="separator:a2694731debfdf03c3fe12fd45f760e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="memItemLeft" align="right" valign="top">size3_t IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab73ec645cb3206ba1ffd1d9bea0747ee">getVolumeDimensions</a> (const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="memdesc:ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the true volume dimensions considering volume margins and bricking  <a href="namespaceinviwo_1_1util.html#ab73ec645cb3206ba1ffd1d9bea0747ee">More...</a><br /></td></tr>
<tr class="separator:ab73ec645cb3206ba1ffd1d9bea0747ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fde21434664ba9e965614cfdf7890fc"><td class="memItemLeft" align="right" valign="top">double IVW_CORE_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4fde21434664ba9e965614cfdf7890fc">voxelVolume</a> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="memdesc:a4fde21434664ba9e965614cfdf7890fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3  <a href="namespaceinviwo_1_1util.html#a4fde21434664ba9e965614cfdf7890fc">More...</a><br /></td></tr>
<tr class="separator:a4fde21434664ba9e965614cfdf7890fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a2ec11e63479fff3c005d159414687d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a2ec11e63479fff3c005d159414687d4e">zip</a> (T &amp;&amp;... args) -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt; T... &gt;</td></tr>
<tr class="separator:a2ec11e63479fff3c005d159414687d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa566d97b543e2bdded79bb2a50c33bb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa566d97b543e2bdded79bb2a50c33bb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa566d97b543e2bdded79bb2a50c33bb0">make_sequence</a> (const T &amp;begin, const T &amp;end, const T &amp;inc=T{1}) -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt; T &gt;</td></tr>
<tr class="separator:aa566d97b543e2bdded79bb2a50c33bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787f4da3b201153820af19c27c2a7fac"><td class="memTemplParams" colspan="2">template&lt;typename TIndex  = size_t, typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a787f4da3b201153820af19c27c2a7fac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a787f4da3b201153820af19c27c2a7fac">enumerate</a> (T &amp;&amp;cont, Ts &amp;&amp;... conts)</td></tr>
<tr class="separator:a787f4da3b201153820af19c27c2a7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0675dad7804acb023b3e9cde6b691aa"><td class="memItemLeft" align="right" valign="top"><a id="ae0675dad7804acb023b3e9cde6b691aa" name="ae0675dad7804acb023b3e9cde6b691aa"></a>
void IVW_QTEDITOR_API&#160;</td><td class="memItemRight" valign="bottom"><b>insertNetworkForData</b> (const std::string &amp;dataFile, <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *net, bool alwaysFirst=false, bool onlySource=false, QWidget *parent=nullptr)</td></tr>
<tr class="separator:ae0675dad7804acb023b3e9cde6b691aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa048b0cf2e27625499d9ac8e03af03d6">isConvex</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aa048b0cf2e27625499d9ac8e03af03d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given polygon is convex  <a href="namespaceinviwo_1_1util.html#aa048b0cf2e27625499d9ac8e03af03d6">More...</a><br /></td></tr>
<tr class="separator:aa048b0cf2e27625499d9ac8e03af03d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a193aac2254d9cc5b5b1029995323d957"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a193aac2254d9cc5b5b1029995323d957">isInside</a> (const std::vector&lt; T &gt; &amp;hull, const T &amp;p)</td></tr>
<tr class="memdesc:a193aac2254d9cc5b5b1029995323d957"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a given point lies within the convex hull  <a href="namespaceinviwo_1_1util.html#a193aac2254d9cc5b5b1029995323d957">More...</a><br /></td></tr>
<tr class="separator:a193aac2254d9cc5b5b1029995323d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aaba0bfadae887301565e97b98483268b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aaba0bfadae887301565e97b98483268b">getArea</a> (const std::vector&lt; T &gt; &amp;polygon)</td></tr>
<tr class="memdesc:aaba0bfadae887301565e97b98483268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the area of a convex polygon  <a href="namespaceinviwo_1_1util.html#aaba0bfadae887301565e97b98483268b">More...</a><br /></td></tr>
<tr class="separator:aaba0bfadae887301565e97b98483268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab6356ee05cfde312881b948335bf689b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab6356ee05cfde312881b948335bf689b">convexHull</a> (const std::vector&lt; T &gt; &amp;points)</td></tr>
<tr class="memdesc:ab6356ee05cfde312881b948335bf689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm  <a href="namespaceinviwo_1_1util.html#ab6356ee05cfde312881b948335bf689b">More...</a><br /></td></tr>
<tr class="separator:ab6356ee05cfde312881b948335bf689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1da85e48a030a3838781befc1b58a6"><td class="memItemLeft" align="right" valign="top"><a id="abd1da85e48a030a3838781befc1b58a6" name="abd1da85e48a030a3838781befc1b58a6"></a>
std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; IVW_MODULE_BASE_API&#160;</td><td class="memItemRight" valign="bottom"><b>convertHullToMesh</b> (const std::vector&lt; vec2 &gt; &amp;hull, bool useIndices=false)</td></tr>
<tr class="separator:abd1da85e48a030a3838781befc1b58a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180d75d9fae76897cebcd13a17c666d7"><td class="memItemLeft" align="right" valign="top"><a id="a180d75d9fae76897cebcd13a17c666d7" name="a180d75d9fae76897cebcd13a17c666d7"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a180d75d9fae76897cebcd13a17c666d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ecdc3de3734eea621ffa06153b4ad4"><td class="memItemLeft" align="right" valign="top"><a id="ad1ecdc3de3734eea621ffa06153b4ad4" name="ad1ecdc3de3734eea621ffa06153b4ad4"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ad1ecdc3de3734eea621ffa06153b4ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d2d204238b274711ad05bb7d99e24b"><td class="memItemLeft" align="right" valign="top"><a id="a40d2d204238b274711ad05bb7d99e24b" name="a40d2d204238b274711ad05bb7d99e24b"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferRAM.html">BufferRAM</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a40d2d204238b274711ad05bb7d99e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d02461aeec59fc568a1edca407e77d"><td class="memItemLeft" align="right" valign="top"><a id="a66d02461aeec59fc568a1edca407e77d" name="a66d02461aeec59fc568a1edca407e77d"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeMinMax</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a66d02461aeec59fc568a1edca407e77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe170b7ad56521599a2f3e401de8392"><td class="memItemLeft" align="right" valign="top"><a id="aafe170b7ad56521599a2f3e401de8392" name="aafe170b7ad56521599a2f3e401de8392"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>layerMinMax</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *layer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:aafe170b7ad56521599a2f3e401de8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f84d47c526824246291b92b4c281959"><td class="memItemLeft" align="right" valign="top"><a id="a3f84d47c526824246291b92b4c281959" name="a3f84d47c526824246291b92b4c281959"></a>
IVW_MODULE_BASE_API std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bufferMinMax</b> (const <a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> *buffer, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a3f84d47c526824246291b92b4c281959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49e61ebf3b11c94b3497f88bb454634"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ae49e61ebf3b11c94b3497f88bb454634"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; dvec4, dvec4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ae49e61ebf3b11c94b3497f88bb454634">dataMinMax</a> (const ValueType *data, size_t size, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:ae49e61ebf3b11c94b3497f88bb454634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a90dfea83005204a1c4beaa3714c38e74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a90dfea83005204a1c4beaa3714c38e74">layerRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a90dfea83005204a1c4beaa3714c38e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635"><td class="memTemplParams" colspan="2"><a id="aa197ca54aa9430e796e41f223f577635" name="aa197ca54aa9430e796e41f223f577635"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa197ca54aa9430e796e41f223f577635"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 2, U &gt; basis, const size2_t upsample)</td></tr>
<tr class="separator:aa197ca54aa9430e796e41f223f577635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplParams" colspan="2"><a id="a26f9879e82cc4d9c7eb77c2724b2d019" name="a26f9879e82cc4d9c7eb77c2724b2d019"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:a26f9879e82cc4d9c7eb77c2724b2d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277"><td class="memTemplParams" colspan="2"><a id="aaae4dea32beba341f6b624c183d07277" name="aaae4dea32beba341f6b624c183d07277"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:aaae4dea32beba341f6b624c183d07277"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback callback)</td></tr>
<tr class="separator:aaae4dea32beba341f6b624c183d07277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplParams" colspan="2"><a id="a6cf8c62d442b8dd2f6be424f09404859" name="a6cf8c62d442b8dd2f6be424f09404859"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6cf8c62d442b8dd2f6be424f09404859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>layerDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *inLayer, <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *outDistanceField, const size2_t upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:a6cf8c62d442b8dd2f6be424f09404859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36aead3fc89df1f8274c4a4ad543f2b"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab36aead3fc89df1f8274c4a4ad543f2b">layerSubSet</a> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *in, ivec2 offset, size2_t <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>, bool clampBorderOutsideImage=false)</td></tr>
<tr class="memdesc:ab36aead3fc89df1f8274c4a4ad543f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a subregion from a layer and returns it as a new layer  <a href="namespaceinviwo_1_1util.html#ab36aead3fc89df1f8274c4a4ad543f2b">More...</a><br /></td></tr>
<tr class="separator:ab36aead3fc89df1f8274c4a4ad543f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f9760ea8997e2913a393a5b0f00baa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96f9760ea8997e2913a393a5b0f00baa"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a96f9760ea8997e2913a393a5b0f00baa">layerSubSet</a> (const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *in, ivec2 offset, size2_t <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>, bool clampBorderOutsideImage=false)</td></tr>
<tr class="memdesc:a96f9760ea8997e2913a393a5b0f00baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a subregion from a layer and converts it into a new layer  <a href="namespaceinviwo_1_1util.html#a96f9760ea8997e2913a393a5b0f00baa">More...</a><br /></td></tr>
<tr class="separator:a96f9760ea8997e2913a393a5b0f00baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ec75b2a503b0e8bf3084fbe9237faa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69ec75b2a503b0e8bf3084fbe9237faa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a69ec75b2a503b0e8bf3084fbe9237faa">haltonSequence</a> (size_t base, size_t numberOfPoints)</td></tr>
<tr class="separator:a69ec75b2a503b0e8bf3084fbe9237faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad439de0e73fffe0976f1f758a3fa3c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad439de0e73fffe0976f1f758a3fa3c1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aad439de0e73fffe0976f1f758a3fa3c1">haltonSequence</a> (size2_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3)</td></tr>
<tr class="separator:aad439de0e73fffe0976f1f758a3fa3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5a54031ffd03ed97bb957ca8f522d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec5a54031ffd03ed97bb957ca8f522d3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aec5a54031ffd03ed97bb957ca8f522d3">haltonSequence</a> (size3_t dims, size_t numberOfPoints, size_t baseX=2, size_t baseY=3, size_t baseZ=5)</td></tr>
<tr class="separator:aec5a54031ffd03ed97bb957ca8f522d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a48b2f672f99a31ee8b19f6f40fa768cb">randomSequence</a> (T *data, size_t numberOfElements, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a48b2f672f99a31ee8b19f6f40fa768cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6f24d3a7fd9df567712ff831321df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a23a6f24d3a7fd9df567712ff831321df"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a23a6f24d3a7fd9df567712ff831321df">randomImage</a> (size2_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a23a6f24d3a7fd9df567712ff831321df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27779344a8c3a59f6cb41222bea0b8e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a27779344a8c3a59f6cb41222bea0b8e2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a27779344a8c3a59f6cb41222bea0b8e2">randomVolume</a> (size3_t dims, Rand &amp;randomNumberGenerator=Rand(), Dist &amp;distribution=Dist(0, 1))</td></tr>
<tr class="separator:a27779344a8c3a59f6cb41222bea0b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150bfe1458dc7fdc648881f4e9abc5ce"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:a150bfe1458dc7fdc648881f4e9abc5ce"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a150bfe1458dc7fdc648881f4e9abc5ce">perlinNoise</a> (size2_t dims, float persistence, size_t startLevel, size_t endLevel, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:a150bfe1458dc7fdc648881f4e9abc5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acaaeed4f22315384c0468633ff1bb2"><td class="memTemplParams" colspan="2">template&lt;typename Rand  = std::mt19937&gt; </td></tr>
<tr class="memitem:a1acaaeed4f22315384c0468633ff1bb2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1acaaeed4f22315384c0468633ff1bb2">poissonDisk</a> (size2_t dims, size_t poissonDotsAlongX, size_t maxPoints, Rand &amp;randomNumberGenerator=Rand())</td></tr>
<tr class="separator:a1acaaeed4f22315384c0468633ff1bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bec0b925a8be26aebea592ce1b00fd2"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5bec0b925a8be26aebea592ce1b00fd2">marchingcubes</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback=std::function&lt; void(float)&gt;(), std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=[](const size3_t &amp;) { return true;})</td></tr>
<tr class="separator:a5bec0b925a8be26aebea592ce1b00fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264903a207983c82b75a97aaa2a69545"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a264903a207983c82b75a97aaa2a69545">marchingCubesOpt</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color, bool invert, bool enclose, std::function&lt; void(float)&gt; progressCallback=nullptr, std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=nullptr)</td></tr>
<tr class="separator:a264903a207983c82b75a97aaa2a69545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c658162fd0c9fb67eb70cfd537e52"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ad05c658162fd0c9fb67eb70cfd537e52">marchingtetrahedron</a> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, double iso, const vec4 &amp;color=vec4(1.0f), bool invert=false, bool enclose=true, std::function&lt; void(float)&gt; progressCallback=std::function&lt; void(float)&gt;(), std::function&lt; bool(const size3_t &amp;)&gt; maskingCallback=[](const size3_t &amp;) { return true;})</td></tr>
<tr class="separator:ad05c658162fd0c9fb67eb70cfd537e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a40a272e79f771e627d2865ad5c61d3"><td class="memItemLeft" align="right" valign="top"><a id="a9a40a272e79f771e627d2865ad5c61d3" name="a9a40a272e79f771e627d2865ad5c61d3"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a9a40a272e79f771e627d2865ad5c61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868dce49fd3bb5fe1e00ae21741e17df"><td class="memItemLeft" align="right" valign="top"><a id="a868dce49fd3bb5fe1e00ae21741e17df" name="a868dce49fd3bb5fe1e00ae21741e17df"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curlVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:a868dce49fd3bb5fe1e00ae21741e17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memItemLeft" align="right" valign="top"><a id="ae2c2e18ffbb9555e3e09fa311430f8eb" name="ae2c2e18ffbb9555e3e09fa311430f8eb"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="separator:ae2c2e18ffbb9555e3e09fa311430f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060da6b81ba276eccef48950775f5d0"><td class="memItemLeft" align="right" valign="top"><a id="a4060da6b81ba276eccef48950775f5d0" name="a4060da6b81ba276eccef48950775f5d0"></a>
IVW_MODULE_BASE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>divergenceVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume)</td></tr>
<tr class="separator:a4060da6b81ba276eccef48950775f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#af36b4e4950c7c433f359ad1e2e32c8ac">generateVolume</a> (const size3_t &amp;dimensions, const mat3 &amp;basis, Functor &amp;&amp;function)</td></tr>
<tr class="separator:af36b4e4950c7c433f359ad1e2e32c8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb99c263ef07f00a0892cf1d9610d15"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a5bb99c263ef07f00a0892cf1d9610d15"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5bb99c263ef07f00a0892cf1d9610d15">makeSingleVoxelVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a5bb99c263ef07f00a0892cf1d9610d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351bc675bcbde3fa893929b312a1b276"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a351bc675bcbde3fa893929b312a1b276"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a351bc675bcbde3fa893929b312a1b276">makeSphericalVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a351bc675bcbde3fa893929b312a1b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5167c56b9fc5c53f102462d89bbf1f11"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a5167c56b9fc5c53f102462d89bbf1f11"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a5167c56b9fc5c53f102462d89bbf1f11">makeRippleVolume</a> (const size3_t &amp;size)</td></tr>
<tr class="separator:a5167c56b9fc5c53f102462d89bbf1f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab618818fcbf3c386f0f07928ce06821f"><td class="memTemplParams" colspan="2">template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:ab618818fcbf3c386f0f07928ce06821f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#ab618818fcbf3c386f0f07928ce06821f">makeMarchingCubeVolume</a> (const size_t &amp;index)</td></tr>
<tr class="separator:ab618818fcbf3c386f0f07928ce06821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fdb400eaf78b7f8917d0c208296133"><td class="memItemLeft" align="right" valign="top"><a id="ac4fdb400eaf78b7f8917d0c208296133" name="ac4fdb400eaf78b7f8917d0c208296133"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gradientVolume</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, int channel)</td></tr>
<tr class="separator:ac4fdb400eaf78b7f8917d0c208296133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a8c467e8ff8b7198cb16f4bacb6755"><td class="memItemLeft" align="right" valign="top"><a id="af6a8c467e8ff8b7198cb16f4bacb6755" name="af6a8c467e8ff8b7198cb16f4bacb6755"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeLaplacian</b> (std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; volume, VolumeLaplacianPostProcessing postProcessing, double scale)</td></tr>
<tr class="separator:af6a8c467e8ff8b7198cb16f4bacb6755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893e468e6145d6106135461cd962371"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:aa893e468e6145d6106135461cd962371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#aa893e468e6145d6106135461cd962371">volumeRAMDistanceTransform</a> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; basis, const size3_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:aa893e468e6145d6106135461cd962371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1864cbcc93e0134e190ad0e41270c31"><td class="memTemplParams" colspan="2"><a id="ad1864cbcc93e0134e190ad0e41270c31" name="ad1864cbcc93e0134e190ad0e41270c31"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad1864cbcc93e0134e190ad0e41270c31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeRAMDistanceTransform</b> (const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const Matrix&lt; 3, U &gt; basis, const size3_t upsample)</td></tr>
<tr class="separator:ad1864cbcc93e0134e190ad0e41270c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51958ead836ffccf0cb9656b1571f9f"><td class="memTemplParams" colspan="2"><a id="ac51958ead836ffccf0cb9656b1571f9f" name="ac51958ead836ffccf0cb9656b1571f9f"></a>
template&lt;typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:ac51958ead836ffccf0cb9656b1571f9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, Predicate predicate, ValueTransform valueTransform, ProgressCallback callback)</td></tr>
<tr class="separator:ac51958ead836ffccf0cb9656b1571f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memTemplParams" colspan="2"><a id="a8564715e4955caf9d9ab0f29cdbee5f1" name="a8564715e4955caf9d9ab0f29cdbee5f1"></a>
template&lt;typename U , typename ProgressCallback &gt; </td></tr>
<tr class="memitem:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, double threshold, bool normalize, bool flip, bool square, double scale, ProgressCallback callback)</td></tr>
<tr class="separator:a8564715e4955caf9d9ab0f29cdbee5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba56f22abced4929a6f4d668e51ca6b"><td class="memTemplParams" colspan="2"><a id="aeba56f22abced4929a6f4d668e51ca6b" name="aeba56f22abced4929a6f4d668e51ca6b"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:aeba56f22abced4929a6f4d668e51ca6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>volumeDistanceTransform</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> *inVolume, <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *outDistanceField, const size3_t upsample, double threshold, bool normalize, bool flip, bool square, double scale)</td></tr>
<tr class="separator:aeba56f22abced4929a6f4d668e51ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff91fe7e398366d3653bb8145922a4"><td class="memItemLeft" align="right" valign="top"><a id="aa6ff91fe7e398366d3653bb8145922a4" name="aa6ff91fe7e398366d3653bb8145922a4"></a>
IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSubSample</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *in, size3_t factors)</td></tr>
<tr class="separator:aa6ff91fe7e398366d3653bb8145922a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a19842e043a90aa4498f0e706a0510"><td class="memItemLeft" align="right" valign="top"><a id="a46a19842e043a90aa4498f0e706a0510" name="a46a19842e043a90aa4498f0e706a0510"></a>
IVW_MODULE_BASE_API size_t&#160;</td><td class="memItemRight" valign="bottom"><b>volumeSignificantVoxels</b> (const <a class="el" href="classinviwo_1_1VolumeRAM.html">VolumeRAM</a> *volume, IgnoreSpecialValues ignore=IgnoreSpecialValues::No)</td></tr>
<tr class="separator:a46a19842e043a90aa4498f0e706a0510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432f4a17defd07381043d6cf56c8ec9b"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a432f4a17defd07381043d6cf56c8ec9b">voronoiSegmentation</a> (const size3_t volumeDimensions, const mat4 &amp;indexToModelMatrix, const std::vector&lt; std::pair&lt; uint32_t, vec3 &gt; &gt; &amp;seedPointsWithIndices, const Wrapping3D &amp;wrapping, const std::optional&lt; std::vector&lt; float &gt; &gt; &amp;weights)</td></tr>
<tr class="separator:a432f4a17defd07381043d6cf56c8ec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3367849b6fdd5d692f75fa2e4e9bd63c"><td class="memItemLeft" align="right" valign="top"><a id="a3367849b6fdd5d692f75fa2e4e9bd63c" name="a3367849b6fdd5d692f75fa2e4e9bd63c"></a>
IVW_MODULE_BASE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>writeDatVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;data, std::string_view filePath, Overwrite overwrite=Overwrite::No)</td></tr>
<tr class="separator:a3367849b6fdd5d692f75fa2e4e9bd63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe22f3aa958e54a96079843918c9a3d"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_BASE_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1fe22f3aa958e54a96079843918c9a3d">writeIvfVolumeSequence</a> (const VolumeSequence &amp;volumes, std::string_view name, std::string_view path, std::string_view relativePathToElements=&quot;&quot;, Overwrite overwrite=Overwrite::Yes)</td></tr>
<tr class="memdesc:a1fe22f3aa958e54a96079843918c9a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a volume sequence to disk.  <a href="namespaceinviwo_1_1util.html#a1fe22f3aa958e54a96079843918c9a3d">More...</a><br /></td></tr>
<tr class="separator:a1fe22f3aa958e54a96079843918c9a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04516bcfebe829bd888357f296aa3cf0"><td class="memItemLeft" align="right" valign="top"><a id="a04516bcfebe829bd888357f296aa3cf0" name="a04516bcfebe829bd888357f296aa3cf0"></a>
IVW_MODULE_BASE_API void&#160;</td><td class="memItemRight" valign="bottom"><b>writeIvfVolume</b> (const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;data, std::string_view filePath, Overwrite overwrite=Overwrite::No)</td></tr>
<tr class="separator:a04516bcfebe829bd888357f296aa3cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dc309f7a28419eb1eaad71adc9bf3"><td class="memItemLeft" align="right" valign="top"><a id="a782dc309f7a28419eb1eaad71adc9bf3" name="a782dc309f7a28419eb1eaad71adc9bf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateReaderFromFile</b> (const <a class="el" href="classinviwo_1_1FileProperty.html">FileProperty</a> &amp;file, <a class="el" href="classinviwo_1_1TemplateOptionProperty.html">TemplateOptionProperty</a>&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;reader)</td></tr>
<tr class="separator:a782dc309f7a28419eb1eaad71adc9bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1473ec531e3e7e4cf4e2a3678acf5c82"><td class="memTemplParams" colspan="2"><a id="a1473ec531e3e7e4cf4e2a3678acf5c82" name="a1473ec531e3e7e4cf4e2a3678acf5c82"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a1473ec531e3e7e4cf4e2a3678acf5c82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateFilenameFilters</b> (const <a class="el" href="classinviwo_1_1DataReaderFactory.html">DataReaderFactory</a> &amp;rf, <a class="el" href="classinviwo_1_1FileProperty.html">FileProperty</a> &amp;file, <a class="el" href="classinviwo_1_1TemplateOptionProperty.html">TemplateOptionProperty</a>&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;reader)</td></tr>
<tr class="separator:a1473ec531e3e7e4cf4e2a3678acf5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e393c6d76cb9610473161c31af319"><td class="memItemLeft" align="right" valign="top"><a id="a1f1e393c6d76cb9610473161c31af319" name="a1f1e393c6d76cb9610473161c31af319"></a>
IVW_MODULE_QTWIDGETS_API IvwKey&#160;</td><td class="memItemRight" valign="bottom"><b>mapKeyFromQt</b> (const QKeyEvent *keyevent)</td></tr>
<tr class="separator:a1f1e393c6d76cb9610473161c31af319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f38b5e8688ab35d2adc3f29daafda0d"><td class="memItemLeft" align="right" valign="top"><a id="a2f38b5e8688ab35d2adc3f29daafda0d" name="a2f38b5e8688ab35d2adc3f29daafda0d"></a>
IVW_MODULE_QTWIDGETS_API MouseCursor&#160;</td><td class="memItemRight" valign="bottom"><b>fromCursorShape</b> (const Qt::CursorShape cursor)</td></tr>
<tr class="separator:a2f38b5e8688ab35d2adc3f29daafda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71be815e81cb5f54def2620dfa51d12"><td class="memItemLeft" align="right" valign="top"><a id="ac71be815e81cb5f54def2620dfa51d12" name="ac71be815e81cb5f54def2620dfa51d12"></a>
IVW_MODULE_QTWIDGETS_API Qt::CursorShape&#160;</td><td class="memItemRight" valign="bottom"><b>toCursorShape</b> (const MouseCursor cursor)</td></tr>
<tr class="separator:ac71be815e81cb5f54def2620dfa51d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0d09b6d1537336c6e8271dcd557c93"><td class="memTemplParams" colspan="2"><a id="aed0d09b6d1537336c6e8271dcd557c93" name="aed0d09b6d1537336c6e8271dcd557c93"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed0d09b6d1537336c6e8271dcd557c93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spherical</b> (T val)</td></tr>
<tr class="separator:aed0d09b6d1537336c6e8271dcd557c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90162d1deee488866fd8a45d341ef3e"><td class="memTemplParams" colspan="2"><a id="af90162d1deee488866fd8a45d341ef3e" name="af90162d1deee488866fd8a45d341ef3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af90162d1deee488866fd8a45d341ef3e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>euclidean</b> (T val)</td></tr>
<tr class="separator:af90162d1deee488866fd8a45d341ef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ab080660bf20a19c866ba0e82ea7f6"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a94ab080660bf20a19c866ba0e82ea7f6">importFromFile</a> (<a class="el" href="classinviwo_1_1TFPrimitiveSet.html">TFPrimitiveSet</a> &amp;primitiveSet, QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:a94ab080660bf20a19c866ba0e82ea7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> from a file. Depending on the underlying type of <code>primitiveSet</code>, either TF primitives or isovalues are imported.  <a href="namespaceinviwo_1_1util.html#a94ab080660bf20a19c866ba0e82ea7f6">More...</a><br /></td></tr>
<tr class="separator:a94ab080660bf20a19c866ba0e82ea7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f8f5a843c5888917700dc7e1daef48"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a19f8f5a843c5888917700dc7e1daef48">exportToFile</a> (const <a class="el" href="classinviwo_1_1TFPrimitiveSet.html">TFPrimitiveSet</a> &amp;primitiveSet, QWidget *parent=nullptr)</td></tr>
<tr class="memdesc:a19f8f5a843c5888917700dc7e1daef48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file. Depending on the underlying type of <code>primitiveSet</code>, either TF primitives or isovalues are exported.  <a href="namespaceinviwo_1_1util.html#a19f8f5a843c5888917700dc7e1daef48">More...</a><br /></td></tr>
<tr class="separator:a19f8f5a843c5888917700dc7e1daef48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416c8d9416964edc5a92908f30761f6f"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_QTWIDGETS_API QMenu *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a416c8d9416964edc5a92908f30761f6f">addTFPresetsMenu</a> (QWidget *parent, QMenu *menu, <a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *property)</td></tr>
<tr class="memdesc:a416c8d9416964edc5a92908f30761f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a submenu containing entries for TF presets of all transfer functions found in the path <code>PathType::TransferFunctions</code>. Upon selecting a menu entry, the respective preset will be loaded by <code>property</code>. The submenu will be disabled if <code>property</code> is read-only.  <a href="namespaceinviwo_1_1util.html#a416c8d9416964edc5a92908f30761f6f">More...</a><br /></td></tr>
<tr class="separator:a416c8d9416964edc5a92908f30761f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a47074b1152f84ef78728a58c5dfadc"><td class="memItemLeft" align="right" valign="top"><a id="a8a47074b1152f84ef78728a58c5dfadc" name="a8a47074b1152f84ef78728a58c5dfadc"></a>
IVW_MODULE_QTWIDGETS_API QMenu *&#160;</td><td class="memItemRight" valign="bottom"><b>addTFColorbrewerPresetsMenu</b> (QWidget *parent, QMenu *menu, <a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *property)</td></tr>
<tr class="separator:a8a47074b1152f84ef78728a58c5dfadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c"><td class="memTemplParams" colspan="2"><a id="aa788814c50164c72361d1e694439182c" name="aa788814c50164c72361d1e694439182c"></a>
template&lt;typename T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aa788814c50164c72361d1e694439182c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>glm2eigen</b> (const T &amp;elem) -&gt; Eigen::Matrix&lt; typename T::value_type, <a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T, 0 &gt;::value, 1 &gt;</td></tr>
<tr class="separator:aa788814c50164c72361d1e694439182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplParams" colspan="2"><a id="a8a657c60e875cedc887757eed4e19ad7" name="a8a657c60e875cedc887757eed4e19ad7"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Rows &gt;=2 &amp;&amp;Rows&lt;=4 &amp;&amp;Cols &gt;=2 &amp;&amp;Cols&lt;=4), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8a657c60e875cedc887757eed4e19ad7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="separator:a8a657c60e875cedc887757eed4e19ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplParams" colspan="2"><a id="ab2bf79aba70128387f4271031a7d37d9" name="ab2bf79aba70128387f4271031a7d37d9"></a>
template&lt;typename T , unsigned Rows, unsigned Cols, typename std::enable_if&lt;(Cols &gt;=2 &amp;&amp;Cols&lt;=4 &amp;&amp;Rows==1), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab2bf79aba70128387f4271031a7d37d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen2glm</b> (const Eigen::Matrix&lt; T, Cols, Cols &gt; &amp;m)</td></tr>
<tr class="separator:ab2bf79aba70128387f4271031a7d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520165892abd0e5fdde34d66c53448a9"><td class="memTemplParams" colspan="2"><a id="a520165892abd0e5fdde34d66c53448a9" name="a520165892abd0e5fdde34d66c53448a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a520165892abd0e5fdde34d66c53448a9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigenMatToImage</b> (const T &amp;m, bool flipY=false, std::string name=&quot;&quot;)</td></tr>
<tr class="separator:a520165892abd0e5fdde34d66c53448a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_FONTRENDERING_API <a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6e1e0f2ae3a7b52b3a951b6fff0411b2">createTextTextureObject</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string including its bounding box.  <a href="namespaceinviwo_1_1util.html#a6e1e0f2ae3a7b52b3a951b6fff0411b2">More...</a><br /></td></tr>
<tr class="separator:a6e1e0f2ae3a7b52b3a951b6fff0411b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7100edcb0e8721bc861233332b7d2c"><td class="memItemLeft" align="right" valign="top">IVW_MODULE_FONTRENDERING_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a4b7100edcb0e8721bc861233332b7d2c">createTextTexture</a> (<a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;textRenderer, std::string text, vec4 fontColor, std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; tex=nullptr)</td></tr>
<tr class="memdesc:a4b7100edcb0e8721bc861233332b7d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture with rendered text for a given string.  <a href="namespaceinviwo_1_1util.html#a4b7100edcb0e8721bc861233332b7d2c">More...</a><br /></td></tr>
<tr class="separator:a4b7100edcb0e8721bc861233332b7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9c6d9a11c0384e31ffbcdc2fdf83a3"><td class="memItemLeft" align="right" valign="top"><a id="a9d9c6d9a11c0384e31ffbcdc2fdf83a3" name="a9d9c6d9a11c0384e31ffbcdc2fdf83a3"></a>
IVW_MODULE_GLFW_API MouseButton&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMouseButton</b> (int mouseButtonGLFW)</td></tr>
<tr class="separator:a9d9c6d9a11c0384e31ffbcdc2fdf83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721227f550ec8159e81af51df349b5cb"><td class="memItemLeft" align="right" valign="top"><a id="a721227f550ec8159e81af51df349b5cb" name="a721227f550ec8159e81af51df349b5cb"></a>
IVW_MODULE_GLFW_API MouseState&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMouseState</b> (int mouseStateGLFW)</td></tr>
<tr class="separator:a721227f550ec8159e81af51df349b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05df5a637223f4c690d7d136137daff7"><td class="memItemLeft" align="right" valign="top"><a id="a05df5a637223f4c690d7d136137daff7" name="a05df5a637223f4c690d7d136137daff7"></a>
IVW_MODULE_GLFW_API KeyModifiers&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWModifiers</b> (int modifiersGLFW)</td></tr>
<tr class="separator:a05df5a637223f4c690d7d136137daff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6451925eaf258ea3a2a0532025dce"><td class="memItemLeft" align="right" valign="top"><a id="ad5d6451925eaf258ea3a2a0532025dce" name="ad5d6451925eaf258ea3a2a0532025dce"></a>
IVW_MODULE_GLFW_API KeyState&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMKeyState</b> (int actionGLFW)</td></tr>
<tr class="separator:ad5d6451925eaf258ea3a2a0532025dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750cb44109ec8f9e4e82c4eca174a17f"><td class="memItemLeft" align="right" valign="top"><a id="a750cb44109ec8f9e4e82c4eca174a17f" name="a750cb44109ec8f9e4e82c4eca174a17f"></a>
IVW_MODULE_GLFW_API IvwKey&#160;</td><td class="memItemRight" valign="bottom"><b>mapGLFWMKey</b> (int keyGLFW)</td></tr>
<tr class="separator:a750cb44109ec8f9e4e82c4eca174a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1587f7d20a684086041c0b7bc6533f"><td class="memItemLeft" align="right" valign="top"><a id="ade1587f7d20a684086041c0b7bc6533f" name="ade1587f7d20a684086041c0b7bc6533f"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:ade1587f7d20a684086041c0b7bc6533f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75398e19046de300d6ea0cb727a87794"><td class="memItemLeft" align="right" valign="top"><a id="a75398e19046de300d6ea0cb727a87794" name="a75398e19046de300d6ea0cb727a87794"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a75398e19046de300d6ea0cb727a87794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d5326c5647d7a9063209eee9ca75c"><td class="memItemLeft" align="right" valign="top"><a id="a976d5326c5647d7a9063209eee9ca75c" name="a976d5326c5647d7a9063209eee9ca75c"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a976d5326c5647d7a9063209eee9ca75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memItemLeft" align="right" valign="top"><a id="adcbd7dfed95f3b9fcc29d2421e3d69f3" name="adcbd7dfed95f3b9fcc29d2421e3d69f3"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:adcbd7dfed95f3b9fcc29d2421e3d69f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5aa12285d95c1792955d4c32de5b29"><td class="memItemLeft" align="right" valign="top"><a id="a6a5aa12285d95c1792955d4c32de5b29" name="a6a5aa12285d95c1792955d4c32de5b29"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a6a5aa12285d95c1792955d4c32de5b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d946d516e1f1f4aaf698472e30486c"><td class="memItemLeft" align="right" valign="top"><a id="aa9d946d516e1f1f4aaf698472e30486c" name="aa9d946d516e1f1f4aaf698472e30486c"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (const <a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:aa9d946d516e1f1f4aaf698472e30486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memItemLeft" align="right" valign="top"><a id="a79b08c3d3861ad6c1820ef8bda2a11d3" name="a79b08c3d3861ad6c1820ef8bda2a11d3"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLine.html">IntegralLine</a> &amp;line, dmat4 toWorld)</td></tr>
<tr class="separator:a79b08c3d3861ad6c1820ef8bda2a11d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memItemLeft" align="right" valign="top"><a id="a8b8cf4d5c05f1080f751a389346a2ef7" name="a8b8cf4d5c05f1080f751a389346a2ef7"></a>
IVW_MODULE_VECTORFIELDVISUALIZATION_API void&#160;</td><td class="memItemRight" valign="bottom"><b>tortuosity</b> (<a class="el" href="classinviwo_1_1IntegralLineSet.html">IntegralLineSet</a> &amp;lines)</td></tr>
<tr class="separator:a8b8cf4d5c05f1080f751a389346a2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b49a23359f08fa4d30f61fc0c56de5a"><td class="memItemLeft" align="right" valign="top">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a1b49a23359f08fa4d30f61fc0c56de5a">boundingBox</a> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;mesh)</td></tr>
<tr class="separator:a1b49a23359f08fa4d30f61fc0c56de5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9ff4b80212faa99dda24be3fd6639c"><td class="memItemLeft" align="right" valign="top"><a id="abf9ff4b80212faa99dda24be3fd6639c" name="abf9ff4b80212faa99dda24be3fd6639c"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0 &gt; &amp;meshes)</td></tr>
<tr class="separator:abf9ff4b80212faa99dda24be3fd6639c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518e5ae03c40b276fc39d55e2cacfc11"><td class="memItemLeft" align="right" valign="top"><a id="a518e5ae03c40b276fc39d55e2cacfc11" name="a518e5ae03c40b276fc39d55e2cacfc11"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a>, 0, true &gt; &amp;meshes)</td></tr>
<tr class="separator:a518e5ae03c40b276fc39d55e2cacfc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c288eeb600394bd546b3def257fb3"><td class="memItemLeft" align="right" valign="top"><a id="ab09c288eeb600394bd546b3def257fb3" name="ab09c288eeb600394bd546b3def257fb3"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;mesh)</td></tr>
<tr class="separator:ab09c288eeb600394bd546b3def257fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd152d8abef09fe85cd9d03d7e5d91d"><td class="memItemLeft" align="right" valign="top"><a id="abdd152d8abef09fe85cd9d03d7e5d91d" name="abdd152d8abef09fe85cd9d03d7e5d91d"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:abdd152d8abef09fe85cd9d03d7e5d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301a4dd68ec13be8ccacafeaa3d5d23c"><td class="memItemLeft" align="right" valign="top"><a id="a301a4dd68ec13be8ccacafeaa3d5d23c" name="a301a4dd68ec13be8ccacafeaa3d5d23c"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:a301a4dd68ec13be8ccacafeaa3d5d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8a1d3278dcc2b4114beb5d398959b"><td class="memItemLeft" align="right" valign="top"><a id="a34f8a1d3278dcc2b4114beb5d398959b" name="a34f8a1d3278dcc2b4114beb5d398959b"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;volume)</td></tr>
<tr class="separator:a34f8a1d3278dcc2b4114beb5d398959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f3306477d0aadf1371e6953688b1e"><td class="memItemLeft" align="right" valign="top"><a id="afa4f3306477d0aadf1371e6953688b1e" name="afa4f3306477d0aadf1371e6953688b1e"></a>
IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boundingBox</b> (const <a class="el" href="classinviwo_1_1DataOutport.html">DataOutport</a>&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &gt; &amp;volumes)</td></tr>
<tr class="separator:afa4f3306477d0aadf1371e6953688b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa77c5fb17124dd9cfba51391fd9e0b52"><td class="memItemLeft" align="right" valign="top"><a id="aa77c5fb17124dd9cfba51391fd9e0b52" name="aa77c5fb17124dd9cfba51391fd9e0b52"></a>
constexpr std::array&lt; std::string_view, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>defaultAxesNames</b> = {&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;t&quot;}</td></tr>
<tr class="separator:aa77c5fb17124dd9cfba51391fd9e0b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b407ab7fe241ff85c95d78cd2d440d"><td class="memItemLeft" align="right" valign="top"><a id="a56b407ab7fe241ff85c95d78cd2d440d" name="a56b407ab7fe241ff85c95d78cd2d440d"></a>
constexpr std::array&lt; Unit, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>defaultAxesUnits</b> = {Unit{}, Unit{}, Unit{}, Unit{}}</td></tr>
<tr class="separator:a56b407ab7fe241ff85c95d78cd2d440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memTemplParams" colspan="2"><a id="a5bcd5c22b1d7609d0bfa1ac9c2366137" name="a5bcd5c22b1d7609d0bfa1ac9c2366137"></a>
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_v</b> = is_detected&lt;Op, Args...&gt;::value</td></tr>
<tr class="separator:a5bcd5c22b1d7609d0bfa1ac9c2366137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c054be71dbad108fc08c950133f5d8"><td class="memTemplParams" colspan="2"><a id="a97c054be71dbad108fc08c950133f5d8" name="a97c054be71dbad108fc08c950133f5d8"></a>
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a97c054be71dbad108fc08c950133f5d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact_v</b> = is_detected_exact&lt;Expected, Op, Args...&gt;::value</td></tr>
<tr class="separator:a97c054be71dbad108fc08c950133f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memTemplParams" colspan="2"><a id="ab60aebc069e6ffb95eec6e91c1b8473d" name="ab60aebc069e6ffb95eec6e91c1b8473d"></a>
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible_v</b> = is_detected_convertible&lt;To, Op, Args...&gt;::value</td></tr>
<tr class="separator:ab60aebc069e6ffb95eec6e91c1b8473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d5bc485266c852e507c1982cff076"><td class="memTemplParams" colspan="2"><a id="ae12d5bc485266c852e507c1982cff076" name="ae12d5bc485266c852e507c1982cff076"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12d5bc485266c852e507c1982cff076"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_floating_point_v</b> = <a class="el" href="structinviwo_1_1util_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae12d5bc485266c852e507c1982cff076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memTemplParams" colspan="2"><a id="abea4ef5c894b02633e6ff1d61f57fd6b" name="abea4ef5c894b02633e6ff1d61f57fd6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_v</b> = <a class="el" href="structinviwo_1_1util_1_1rank.html">rank</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abea4ef5c894b02633e6ff1d61f57fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10a8a24583b2bd0047115a9e370bef6"><td class="memTemplParams" colspan="2"><a id="ab10a8a24583b2bd0047115a9e370bef6" name="ab10a8a24583b2bd0047115a9e370bef6"></a>
template&lt;class T , unsigned N = 0&gt; </td></tr>
<tr class="memitem:ab10a8a24583b2bd0047115a9e370bef6"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extent_v</b> = <a class="el" href="structinviwo_1_1util_1_1extent.html">extent</a>&lt;T, N&gt;::value</td></tr>
<tr class="separator:ab10a8a24583b2bd0047115a9e370bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177809ac774c60ba26acf2a0434f1dd"><td class="memTemplParams" colspan="2"><a id="a2177809ac774c60ba26acf2a0434f1dd" name="a2177809ac774c60ba26acf2a0434f1dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2177809ac774c60ba26acf2a0434f1dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_extent_v</b> = <a class="el" href="structinviwo_1_1util_1_1flat__extent.html">flat_extent</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a2177809ac774c60ba26acf2a0434f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6f2c783a1cc78c23c5060fc9e8425e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinviwo_1_1util.html#a6c6f2c783a1cc78c23c5060fc9e8425e">fmtHelp</a></td></tr>
<tr class="separator:a6c6f2c783a1cc78c23c5060fc9e8425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >util </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a2b5f1041e36b51c7bdbeb40c5d836fc0" name="a2b5f1041e36b51c7bdbeb40c5d836fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5f1041e36b51c7bdbeb40c5d836fc0">&#9670;&nbsp;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">inviwo::util::PrecisionType</a> = typedef typename std::remove_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div>
<div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, <a class="code hl_struct" href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">dispatching::filter::Vecs</a>&gt;([](<span class="keyword">auto</span> vrprecision) {</div>
<div class="line">    <span class="keyword">using</span> VolumeType = <a class="code hl_typedef" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">util::PrecisionType</a>&lt;<span class="keyword">decltype</span>(vrprecision)&gt;;</div>
<div class="line">    ....</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a2b5f1041e36b51c7bdbeb40c5d836fc0"><div class="ttname"><a href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">inviwo::util::PrecisionType</a></div><div class="ttdeci">typename std::remove_pointer&lt; typename std::remove_const&lt; T &gt;::type &gt;::type PrecisionType</div><div class="ttdef"><b>Definition:</b> formatdispatching.h:324</div></div>
<div class="ttc" id="astructinviwo_1_1dispatching_1_1filter_1_1Vecs_html"><div class="ttname"><a href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">inviwo::dispatching::filter::Vecs</a></div><div class="ttdef"><b>Definition:</b> formatdispatching.h:224</div></div>
</div><!-- fragment --><p> VolumeType will then be for example VolumeRamPrecision&lt;vec3&gt; </p>

</div>
</div>
<a id="ab46a88fc5a27a696a911ff806d367b56" name="ab46a88fc5a27a696a911ff806d367b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46a88fc5a27a696a911ff806d367b56">&#9670;&nbsp;</a></span>PrecisionValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceinviwo_1_1util.html#ab46a88fc5a27a696a911ff806d367b56">inviwo::util::PrecisionValueType</a> = typedef typename <a class="el" href="namespaceinviwo_1_1util.html#a2b5f1041e36b51c7bdbeb40c5d836fc0">PrecisionType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility for retrieving the type of a (Buffer/Layer/Volume)RamPrecision pointer variable. Example usage: </p><div class="fragment"><div class="line">VolumeRam* volumeram = ...; <span class="comment">// of some glm vector type.</span></div>
<div class="line"><span class="keyword">auto</span> count = volumeram-&gt;dispatch&lt;size_t, <a class="code hl_struct" href="structinviwo_1_1dispatching_1_1filter_1_1Vecs.html">dispatching::filter::Vecs</a>&gt;([](<span class="keyword">auto</span> vrprecision) {</div>
<div class="line">    <span class="keyword">using</span> ValueType = <a class="code hl_typedef" href="namespaceinviwo_1_1util.html#ab46a88fc5a27a696a911ff806d367b56">util::PrecisionValueType</a>&lt;<span class="keyword">decltype</span>(vrprecision)&gt;;</div>
<div class="line">    ....</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_ab46a88fc5a27a696a911ff806d367b56"><div class="ttname"><a href="namespaceinviwo_1_1util.html#ab46a88fc5a27a696a911ff806d367b56">inviwo::util::PrecisionValueType</a></div><div class="ttdeci">typename PrecisionType&lt; T &gt;::type PrecisionValueType</div><div class="ttdef"><b>Definition:</b> formatdispatching.h:342</div></div>
</div><!-- fragment --><p> ValueType will then be for example vec3 </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a416c8d9416964edc5a92908f30761f6f" name="a416c8d9416964edc5a92908f30761f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416c8d9416964edc5a92908f30761f6f">&#9670;&nbsp;</a></span>addTFPresetsMenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API QMenu * inviwo::util::addTFPresetsMenu </td>
          <td>(</td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMenu *&#160;</td>
          <td class="paramname"><em>menu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TransferFunctionProperty.html">TransferFunctionProperty</a> *&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a submenu containing entries for TF presets of all transfer functions found in the path <code>PathType::TransferFunctions</code>. Upon selecting a menu entry, the respective preset will be loaded by <code>property</code>. The submenu will be disabled if <code>property</code> is read-only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent widget </td></tr>
    <tr><td class="paramname">menu</td><td>parent menu to which the TF preset submenu should be added </td></tr>
    <tr><td class="paramname">property</td><td>this property will load the TF presets once the menu entries are triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly created submenu, which is owned by <code>parent</code> </dd></dl>

</div>
</div>
<a id="a2f406a130b054515fd4dceb5b35b84ba" name="a2f406a130b054515fd4dceb5b35b84ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f406a130b054515fd4dceb5b35b84ba">&#9670;&nbsp;</a></span>alignAlphaToBottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToBottom </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the alphas value of selection to the min alpha value. </p>

</div>
</div>
<a id="ad833fb2a28acd35e6be134baa81331fa" name="ad833fb2a28acd35e6be134baa81331fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833fb2a28acd35e6be134baa81331fa">&#9670;&nbsp;</a></span>alignAlphaToMean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToMean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the alphas value of selection to the average alpha value. </p>

</div>
</div>
<a id="a92665c9b8c2cd085faf8e4b701edbdc7" name="a92665c9b8c2cd085faf8e4b701edbdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92665c9b8c2cd085faf8e4b701edbdc7">&#9670;&nbsp;</a></span>alignAlphaToTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignAlphaToTop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the alphas value of selection to the max alpha value. </p>

</div>
</div>
<a id="a27792fd235656d42d7e286db7cdc4bd3" name="a27792fd235656d42d7e286db7cdc4bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27792fd235656d42d7e286db7cdc4bd3">&#9670;&nbsp;</a></span>alignPositionToLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToLeft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the position value of selection to the min position value. </p>

</div>
</div>
<a id="a6fd54c996575d2b47bea52c51ee3ec14" name="a6fd54c996575d2b47bea52c51ee3ec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd54c996575d2b47bea52c51ee3ec14">&#9670;&nbsp;</a></span>alignPositionToMean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToMean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the position value of selection to the average position value. </p>

</div>
</div>
<a id="a886b02bc8bf08edc11981f255bdc9780" name="a886b02bc8bf08edc11981f255bdc9780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886b02bc8bf08edc11981f255bdc9780">&#9670;&nbsp;</a></span>alignPositionToRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::alignPositionToRight </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the position value of selection to the max position value. </p>

</div>
</div>
<a id="a71d8f37ab73d4d9bf20018bd26a64910" name="a71d8f37ab73d4d9bf20018bd26a64910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d8f37ab73d4d9bf20018bd26a64910">&#9670;&nbsp;</a></span>appendIfNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::appendIfNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends b to a if a is not empty and returns a. Useful if an empty a is considered an error and we want to propagate that error. </p>

</div>
</div>
<a id="a1b49a23359f08fa4d30f61fc0c56de5a" name="a1b49a23359f08fa4d30f61fc0c56de5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b49a23359f08fa4d30f61fc0c56de5a">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::function&lt; std::optional&lt; mat4 &gt;()&gt; inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1DataInport.html">DataInport</a>&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructs a function that returns the bounding box of the data in the port. If the port is empty the function should return std::nullopt; </p>

</div>
</div>
<a id="a74a73f5197bbfc5940421cee5d8f5755" name="a74a73f5197bbfc5940421cee5d8f5755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a73f5197bbfc5940421cee5d8f5755">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a bounding box of the position buffer of the mesh in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="aa7a49c8d7b70aa04748e46e77aaa4bf3" name="aa7a49c8d7b70aa04748e46e77aaa4bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a49c8d7b70aa04748e46e77aaa4bf3">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a bounding box of the position buffers of all the meshs in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="a07503961e01f5f633c9f1a371b36d780" name="a07503961e01f5f633c9f1a371b36d780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07503961e01f5f633c9f1a371b36d780">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>volumes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a bounding box of all the volumes in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="ac6b304bd97447cbc99865cf2a8bdc3a9" name="ac6b304bd97447cbc99865cf2a8bdc3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b304bd97447cbc99865cf2a8bdc3a9">&#9670;&nbsp;</a></span>boundingBox() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API mat4 inviwo::util::boundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculate a bounding box of the volume in world space. The bounding box is represented using a mat4, where all positions are between `bbox * (x,y,z,1) where x, y, and z are between 0 and 1. </p>

</div>
</div>
<a id="ab6356ee05cfde312881b948335bf689b" name="ab6356ee05cfde312881b948335bf689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6356ee05cfde312881b948335bf689b">&#9670;&nbsp;</a></span>convexHull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; inviwo::util::convexHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the complex hull from a given set of 2D points using the Monotone Chain algorithm, i.e. Andrew's convex hull algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms">https://en.wikipedia.org/wiki/Convex_hull_algorithms#Algorithms</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>set of 2D points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>complex hull of input points </dd></dl>

</div>
</div>
<a id="a5e2a9a37232b9367cf8bc52093935b37" name="a5e2a9a37232b9367cf8bc52093935b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2a9a37232b9367cf8bc52093935b37">&#9670;&nbsp;</a></span>createCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> &gt; inviwo::util::createCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; vec2()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const vec2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an eye offset property for use in a camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="ad1562123df97b5129796b73f231e1bd5" name="ad1562123df97b5129796b73f231e1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1562123df97b5129796b73f231e1bd5">&#9670;&nbsp;</a></span>createCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt; inviwo::util::createCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vertical fov property for use in a camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="a53cd42ede5eb2f1d94c2405c9f36c005" name="a53cd42ede5eb2f1d94c2405c9f36c005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cd42ede5eb2f1d94c2405c9f36c005">&#9670;&nbsp;</a></span>createCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::unique_ptr&lt; <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> &gt; inviwo::util::createCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a width property for use in a <a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="a4b7100edcb0e8721bc861233332b7d2c" name="a4b7100edcb0e8721bc861233332b7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7100edcb0e8721bc861233332b7d2c">&#9670;&nbsp;</a></span>createTextTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt; inviwo::util::createTextTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>textRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4&#160;</td>
          <td class="paramname"><em>fontColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td>
          <td class="paramname"><em>tex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string. </p>
<p >Creates a texture with a text string using the specified renderer and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures.</p>
<p >The size of the texture will be the smallest possible for the given text and the pixels containing no text will have zero alpha.</p>
<p >For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + computeBoundingBox(text).glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#acfb36fb35fcf8c986eb72ca473a75806">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>text to be rendered </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>texture containing the text </dd></dl>

</div>
</div>
<a id="a6e1e0f2ae3a7b52b3a951b6fff0411b2" name="a6e1e0f2ae3a7b52b3a951b6fff0411b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1e0f2ae3a7b52b3a951b6fff0411b2">&#9670;&nbsp;</a></span>createTextTextureObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_FONTRENDERING_API <a class="el" href="structinviwo_1_1TextTextureObject.html">TextTextureObject</a> inviwo::util::createTextTextureObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TextRenderer.html">TextRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>textRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4&#160;</td>
          <td class="paramname"><em>fontColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Texture2D.html">Texture2D</a> &gt;&#160;</td>
          <td class="paramname"><em>tex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture with rendered text for a given string including its bounding box. </p>
<p >Creates a texture with rendered text for a string using the specified renderer and color. May take an additional variable tex of an existing texture that can be reused to reduce the number of times we need to allocating new textures. The resulting texture is returned along with the respective bounding box.</p>
<p >The size of the texture will be the smallest possible for the given text. All pixels containing no text will have zero alpha.</p>
<p >For correct alignment of the baseline, the position of where this texture will be rendered must be adjusted by pos + TextTextureObject.glyphsOrigin. See also <a class="el" href="classinviwo_1_1TextOverlayGL.html#acfb36fb35fcf8c986eb72ca473a75806">TextOverlayGL::process()</a> as an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textRenderer</td><td>The renderer that will be used to render the text </td></tr>
    <tr><td class="paramname">text</td><td>string to be rendered </td></tr>
    <tr><td class="paramname">fontColor</td><td>the final color of the text </td></tr>
    <tr><td class="paramname">tex</td><td>optional cache texture which will be reused if possible (same texture will be returned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>text texture object referring to both texture and corresponding bounding box </dd></dl>

</div>
</div>
<a id="a125fdc1aa254554458167122ca14c08b" name="a125fdc1aa254554458167122ca14c08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125fdc1aa254554458167122ca14c08b">&#9670;&nbsp;</a></span>cubePlaneIntersectionAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::cubePlaneIntersectionAppend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vec3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Intersects a unit cube with the given plane. The intersection points and the midpoint will be added to 'pos' and a list of triangle indicies referring to the pos array will be appended to 'inds' </p>

</div>
</div>
<a id="ae49e61ebf3b11c94b3497f88bb454634" name="ae49e61ebf3b11c94b3497f88bb454634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49e61ebf3b11c94b3497f88bb454634">&#9670;&nbsp;</a></span>dataMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; dvec4, dvec4 &gt; inviwo::util::dataMinMax </td>
          <td>(</td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IgnoreSpecialValues&#160;</td>
          <td class="paramname"><em>ignore</em> = <code>IgnoreSpecialValues::No</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute component-wise minimum and maximum values scalar and glm::vec types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to values </td></tr>
    <tr><td class="paramname">size</td><td>of data </td></tr>
    <tr><td class="paramname">ignore</td><td>infinite and NaN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum and maximum values of each component and zero for non-existing components </dd></dl>

</div>
</div>
<a id="aa0b234248fa0f75afa5d053118ec319a" name="aa0b234248fa0f75afa5d053118ec319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b234248fa0f75afa5d053118ec319a">&#9670;&nbsp;</a></span>elideLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::elideLines </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>abbrev</em> = <code>&quot;...&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLineLength</em> = <code>500</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elide parts of lines in <code>str</code> which are longer than <code>maxLineLength</code> and append <code>abbrev</code> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string with lines to abbreviate </td></tr>
    <tr><td class="paramname">abbrev</td><td>placeholder that gets added at the end of abbreviated lines </td></tr>
    <tr><td class="paramname">maxLineLength</td><td>lines that are longer are abbreviated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input string where no line is longer than <code>maxLineLength</code> + <code>abbrev.size()</code> </dd></dl>

</div>
</div>
<a id="a787f4da3b201153820af19c27c2a7fac" name="a787f4da3b201153820af19c27c2a7fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787f4da3b201153820af19c27c2a7fac">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIndex  = size_t, typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::enumerate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>conts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enumerate element in a container. Example use case: std::vector&lt;int&gt; vec(10); for (auto&amp;&amp; item : util::enumerate(vec)) { auto&amp;&amp; ind = item.first(); auto&amp;&amp; elem = item.second(); // alternatively, get&lt;0&gt;(item) and get&lt;1&gt;(item) can be used }</p>
<p >with C++17 structured bindings for (auto&amp;&amp; [ind, elem] : util::enumerate(vec)) {</p>
<p >} </p>

</div>
</div>
<a id="a4c89b716938f61f15132ae42d6d4a16b" name="a4c89b716938f61f15132ae42d6d4a16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c89b716938f61f15132ae42d6d4a16b">&#9670;&nbsp;</a></span>expandCompositeProcessorIntoNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::expandCompositeProcessorIntoNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CompositeProcessor.html">CompositeProcessor</a> &amp;&#160;</td>
          <td class="paramname"><em>composite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Expand a composite processors sub network into its network. Effectively reversing the actions of replaceSelectionWithCompositeProcessor. All processor except for composite sink and composite source processors are moved from the sub network into the network of the composite processor. Connections and links are the reestablished. Sources and sinks are discarded. </p>

</div>
</div>
<a id="ae539abc6359b34c4a21ed1928c8f5500" name="ae539abc6359b34c4a21ed1928c8f5500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae539abc6359b34c4a21ed1928c8f5500">&#9670;&nbsp;</a></span>exportAllFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string &gt; inviwo::util::exportAllFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>nameTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidateExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exports the data from all export processors in <code>network</code> into the directory <code>dir</code> using a <code>nameTemplate</code> and candidate extensions. </p><dl class="section return"><dt>Returns</dt><dd>names of exported files </dd></dl>

</div>
</div>
<a id="a19f8f5a843c5888917700dc7e1daef48" name="a19f8f5a843c5888917700dc7e1daef48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f8f5a843c5888917700dc7e1daef48">&#9670;&nbsp;</a></span>exportToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API void inviwo::util::exportToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1TFPrimitiveSet.html">TFPrimitiveSet</a> &amp;&#160;</td>
          <td class="paramname"><em>primitiveSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to export a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> to a file. Depending on the underlying type of <code>primitiveSet</code>, either TF primitives or isovalues are exported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveSet</td><td>primitive set to be exported (either TF or isovalues) </td></tr>
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b594a5638571d9e20783d8843f3c38" name="ad2b594a5638571d9e20783d8843f3c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b594a5638571d9e20783d8843f3c38">&#9670;&nbsp;</a></span>filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename T  = typename M::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M inviwo::util::filled </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to create a matrix filled with a constant. For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> m = util::filled&lt;mat3&gt;(3.16);</div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
<div class="line"><span class="comment">// | 3.16 3.16 3.16 |</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a1641752b9b6ec1384f983f1f7b86a9" name="a2a1641752b9b6ec1384f983f1f7b86a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1641752b9b6ec1384f983f1f7b86a9">&#9670;&nbsp;</a></span>findUniqueIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::findUniqueIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(std::string_view)&gt;&#160;</td>
          <td class="paramname"><em>isUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility to augment an identifier with a number to make it unique. Will add an increasing number to the end of the given identifier until the isUnique test returns true. Example for a processor identifier: auto uniqueIdentifier = <a class="el" href="namespaceinviwo_1_1util.html#a2a1641752b9b6ec1384f983f1f7b86a9">util::findUniqueIdentifier</a>( startIdentifier, [&amp;](std::string_view id) { return processorNetwork-&gt;getProcessorByIdentifier(id) == nullptr; }, "" ); </p>

</div>
</div>
<a id="a0cb3c9707e78b11bc105e3b2614f1621" name="a0cb3c9707e78b11bc105e3b2614f1621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb3c9707e78b11bc105e3b2614f1621">&#9670;&nbsp;</a></span>flipPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::flipPositions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Flip the positions of the <code>selection</code> with respect to the respective range, i.e. p' = range.max - (p - range.min) with range.min/max corresponding to the lowest/highest position in <code>selection</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selection</td><td>list of primitives to be flipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb6b8dfc1fe3a44825c0a2dbbc2ae65a" name="aeb6b8dfc1fe3a44825c0a2dbbc2ae65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b8dfc1fe3a44825c0a2dbbc2ae65a">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEach </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to iterate over all element in an iterable data structure (such as std::vector). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3ba8edf9868ee32bb79ba5f1c1b114" name="adc3ba8edf9868ee32bb79ba5f1c1b114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3ba8edf9868ee32bb79ba5f1c1b114">&#9670;&nbsp;</a></span>forEachParallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::forEachParallel </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jobs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has finished processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5152f1acc0ccd5f17aef14a459df80b0" name="a5152f1acc0ccd5f17aef14a459df80b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5152f1acc0ccd5f17aef14a459df80b0">&#9670;&nbsp;</a></span>forEachParallelAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Callback , typename OnDoneCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::future&lt; void &gt; &gt; inviwo::util::forEachParallelAsync </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnDoneCallback &amp;&amp;&#160;</td>
          <td class="paramname"><em>onTaskDone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use multiple threads to iterate over all elements in an iterable data structure (such as std::vector). If the Inviwo pool size is zero it will be executed directly in the same thread as the caller. The function will return once all jobs as has been created and queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>the data structure to iterate over </td></tr>
    <tr><td class="paramname">callback</td><td>to call for each element, can be either <code>[](auto &amp;a){}</code> or <code>[](auto &amp;a, size_t id){}</code> where <code>a</code> is an data item from the iterable data structure and <code>id</code> is the index in the data structure </td></tr>
    <tr><td class="paramname">jobs</td><td>optional parameter specifying how many jobs to create, if jobs==0 (default) it will create pool size * 4 jobs </td></tr>
    <tr><td class="paramname">onTaskDone</td><td>callback that will be called when each job is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of futures, one for each job created. </dd></dl>

</div>
</div>
<a id="a040967fe9b1828c138864fcff6d60c0d" name="a040967fe9b1828c138864fcff6d60c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040967fe9b1828c138864fcff6d60c0d">&#9670;&nbsp;</a></span>forEachStringPart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void inviwo::util::forEachStringPart </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on each part of the string after splitting by sep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">sep</td><td>The delimiter to split by </td></tr>
    <tr><td class="paramname">func</td><td>Function callback, should take a std::string_view as argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ec5e6658368eb78ce7b3161c63eddb" name="a53ec5e6658368eb78ce7b3161c63eddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ec5e6658368eb78ce7b3161c63eddb">&#9670;&nbsp;</a></span>fromWstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::fromWstring </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given std::wstring to std::string. On Windows, WideCharToMultiByte is used for this conversion assuming utf8 encoding. Otherwise, std::wcsrtombs is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>std::wstring character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to multibyte std::string </dd></dl>

</div>
</div>
<a id="af36b4e4950c7c433f359ad1e2e32c8ac" name="af36b4e4950c7c433f359ad1e2e32c8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b4e4950c7c433f359ad1e2e32c8ac">&#9670;&nbsp;</a></span>generateVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::generateVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat3 &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convenience function for generating volumes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> grid dimensions </td></tr>
    <tr><td class="paramname">basis</td><td><a class="el" href="classinviwo_1_1Volume.html">Volume</a> basis, offset automatically set to center the volume around origo </td></tr>
    <tr><td class="paramname">function</td><td>Functor called for each volume voxel. T(const size3_t&amp; ind). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba0bfadae887301565e97b98483268b" name="aaba0bfadae887301565e97b98483268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba0bfadae887301565e97b98483268b">&#9670;&nbsp;</a></span>getArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double inviwo::util::getArea </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the area of a convex polygon </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>points ordered counter-clockwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>area of polygon </dd></dl>

</div>
</div>
<a id="a8256eb5b33cde59a3e0d832b0569d323" name="a8256eb5b33cde59a3e0d832b0569d323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8256eb5b33cde59a3e0d832b0569d323">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve bounding box of the processors in the list. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="ade9c4d7699d86580d306484f30f7110d" name="ade9c4d7699d86580d306484f30f7110d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9c4d7699d86580d306484f30f7110d">&#9670;&nbsp;</a></span>getBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::pair&lt; ivec2, ivec2 &gt; inviwo::util::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve bounding box of the processors in the network. The return value is pair of the min x,y and the max x,y </p>

</div>
</div>
<a id="a770d8229540ecf6f0fd353141bae69cd" name="a770d8229540ecf6f0fd353141bae69cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770d8229540ecf6f0fd353141bae69cd">&#9670;&nbsp;</a></span>getBuildInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1util_1_1BuildInfo.html">BuildInfo</a> IVW_CORE_API inviwo::util::getBuildInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses build information via an INI file or compile-time definitions. </p>
<dl class="section return"><dt>Returns</dt><dd>build information </dd></dl>

</div>
</div>
<a id="aae046e2b3232a4ce60452ccc5853efb9" name="aae046e2b3232a4ce60452ccc5853efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae046e2b3232a4ce60452ccc5853efb9">&#9670;&nbsp;</a></span>getCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> * inviwo::util::getCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the eye offset property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the eye offset property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="ad37abc25e96c99f34aac8f37606c7df4" name="ad37abc25e96c99f34aac8f37606c7df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37abc25e96c99f34aac8f37606c7df4">&#9670;&nbsp;</a></span>getCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::getCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the vertical fov property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fov property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="a8cfe78f266537021920d03efb74a15a3" name="a8cfe78f266537021920d03efb74a15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfe78f266537021920d03efb74a15a3">&#9670;&nbsp;</a></span>getCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::getCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the width property in the cameraProperty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraProperty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width property if found, nullptr otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="a9814ba491ab54162a61144582fff0dbd" name="a9814ba491ab54162a61144582fff0dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814ba491ab54162a61144582fff0dbd">&#9670;&nbsp;</a></span>getCenterPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the mean position of the processors in the list. </p>

</div>
</div>
<a id="a930eff3a3f70e0c02c85a55c99c13166" name="a930eff3a3f70e0c02c85a55c99c13166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930eff3a3f70e0c02c85a55c99c13166">&#9670;&nbsp;</a></span>getCenterPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getCenterPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the mean position of the processors in the network. </p>

</div>
</div>
<a id="a86d2b2443c5b46240122de8b5dd5b400" name="a86d2b2443c5b46240122de8b5dd5b400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d2b2443c5b46240122de8b5dd5b400">&#9670;&nbsp;</a></span>getDefaultTimerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> &amp; inviwo::util::getDefaultTimerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the default <a class="el" href="classinviwo_1_1TimerThread.html">TimerThread</a> from the app. </p>

</div>
</div>
<a id="a458419095875341f984870e6f8e9fd13" name="a458419095875341f984870e6f8e9fd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458419095875341f984870e6f8e9fd13">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> </p>

</div>
</div>
<a id="a608356f2ce89e1326c5ab6910337a907" name="a608356f2ce89e1326c5ab6910337a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608356f2ce89e1326c5ab6910337a907">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> </p>

</div>
</div>
<a id="aba248938bdec0647ee6706ea2ece4c8c" name="aba248938bdec0647ee6706ea2ece4c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba248938bdec0647ee6706ea2ece4c8c">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> </p>

</div>
</div>
<a id="a6ab66fbd51685a6de63dfd0e06b89013" name="a6ab66fbd51685a6de63dfd0e06b89013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab66fbd51685a6de63dfd0e06b89013">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Property.html">Property</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> </p>

</div>
</div>
<a id="a0baa816930736caaf0d8b9f4e0733723" name="a0baa816930736caaf0d8b9f4e0733723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baa816930736caaf0d8b9f4e0733723">&#9670;&nbsp;</a></span>getInviwoApplication() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> * inviwo::util::getInviwoApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to get the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> from a <a class="el" href="classinviwo_1_1PropertyOwner.html">PropertyOwner</a> </p>

</div>
</div>
<a id="ace9922dfbd31bfe3e88cb73d3807f80f" name="ace9922dfbd31bfe3e88cb73d3807f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9922dfbd31bfe3e88cb73d3807f80f">&#9670;&nbsp;</a></span>getLibrarySearchPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string &gt; inviwo::util::getLibrarySearchPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns paths to search for module libraries. All platforms: executable directory and application modules directory (AppData/Inviwo/modules on windows). Platform dependent search directories: OSX: DYLD_LIBRARY_PATH UNIX: LD_LIBRARY_PATH/LD_RUN_PATH, RPATH and "executable directory
/../../lib". </p>
<dl class="section return"><dt>Returns</dt><dd>List of paths to directories </dd></dl>

</div>
</div>
<a id="a72f0efd826c637426672e1c60dd26c52" name="a72f0efd826c637426672e1c60dd26c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f0efd826c637426672e1c60dd26c52">&#9670;&nbsp;</a></span>getMetaData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API const <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="af74c8c14214ac56aeafc8d0165333c57" name="af74c8c14214ac56aeafc8d0165333c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74c8c14214ac56aeafc8d0165333c57">&#9670;&nbsp;</a></span>getMetaData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1ProcessorMetaData.html">ProcessorMetaData</a> * inviwo::util::getMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the meta data of the processor. </p>

</div>
</div>
<a id="a5f521098da377963713d6db28a4d5f6e" name="a5f521098da377963713d6db28a4d5f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f521098da377963713d6db28a4d5f6e">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API ivec2 inviwo::util::getPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the position of the processor. </p>

</div>
</div>
<a id="a1ad4b58375e9767217d380b694a0f008" name="a1ad4b58375e9767217d380b694a0f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad4b58375e9767217d380b694a0f008">&#9670;&nbsp;</a></span>getPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the positions of the processors in the list. </p>

</div>
</div>
<a id="a917b0dac4338ee41354df68a988d4bca" name="a917b0dac4338ee41354df68a988d4bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917b0dac4338ee41354df68a988d4bca">&#9670;&nbsp;</a></span>getPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; ivec2 &gt; inviwo::util::getPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> *&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the positions of the processors in the network. </p>

</div>
</div>
<a id="a97b3a4cdb6bbdfa1398237053e844f65" name="a97b3a4cdb6bbdfa1398237053e844f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b3a4cdb6bbdfa1398237053e844f65">&#9670;&nbsp;</a></span>getProcessorModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> * inviwo::util::getProcessorModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find which module that registered a processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classinviwo_1_1InviwoModule.html" title="A module class contains registrations of functionality, such as processors, ports,...">InviwoModule</a> that registered the processor or nullptr if not found </dd></dl>

</div>
</div>
<a id="a4ee3e86bf4e266b4a15880bf67c34d8a" name="a4ee3e86bf4e266b4a15880bf67c34d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee3e86bf4e266b4a15880bf67c34d8a">&#9670;&nbsp;</a></span>getProcessorModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1InviwoModule.html">InviwoModule</a> * inviwo::util::getProcessorModule </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>classIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find which module that registered a processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classIdentifier</td><td>the class identifier of the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classinviwo_1_1InviwoModule.html" title="A module class contains registrations of functionality, such as processors, ports,...">InviwoModule</a> that registered the processor or nullptr if not found </dd></dl>

</div>
</div>
<a id="aa3d0fa4ad06fba067f12d5f75e38b715" name="aa3d0fa4ad06fba067f12d5f75e38b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d0fa4ad06fba067f12d5f75e38b715">&#9670;&nbsp;</a></span>getProcessorModuleIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::optional&lt; std::string &gt; inviwo::util::getProcessorModuleIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>classIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1InviwoApplication.html">InviwoApplication</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the module identifier of a registered processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classIdentifier</td><td>the class identifier of the processor to look for </td></tr>
    <tr><td class="paramname">app</td><td>the <a class="el" href="classinviwo_1_1InviwoApplication.html" title="The main application which holds the instances of all modules.">InviwoApplication</a> needed to get the modules </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identifer of the module that registered the processor or nullopt if not found </dd></dl>

</div>
</div>
<a id="ab73ec645cb3206ba1ffd1d9bea0747ee" name="ab73ec645cb3206ba1ffd1d9bea0747ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73ec645cb3206ba1ffd1d9bea0747ee">&#9670;&nbsp;</a></span>getVolumeDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size3_t IVW_CORE_API inviwo::util::getVolumeDimensions </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the true volume dimensions considering volume margins and bricking </p>
<dl class="section return"><dt>Returns</dt><dd>true volume dimensions </dd></dl>

</div>
</div>
<a id="a2694731debfdf03c3fe12fd45f760e22" name="a2694731debfdf03c3fe12fd45f760e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2694731debfdf03c3fe12fd45f760e22">&#9670;&nbsp;</a></span>getVolumeMargins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; vec3, vec3 &gt; IVW_CORE_API inviwo::util::getVolumeMargins </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the margins of a volume, in normalized texture coordinates [0,1] </p>
<dl class="section return"><dt>Returns</dt><dd>pair of margins from the bottom left corner and the top right corner </dd></dl>

</div>
</div>
<a id="aad439de0e73fffe0976f1f758a3fa3c1" name="aad439de0e73fffe0976f1f758a3fa3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad439de0e73fffe0976f1f758a3fa3c1">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseX</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseY</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with sparse noise based on a pair of two Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceinviwo_1_1util.html#a69ec75b2a503b0e8bf3084fbe9237faa">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting image. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec5a54031ffd03ed97bb957ca8f522d3" name="aec5a54031ffd03ed97bb957ca8f522d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5a54031ffd03ed97bb957ca8f522d3">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size3_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseX</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseY</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>baseZ</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with sparse noise based on a three Halton Sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceinviwo_1_1util.html#a69ec75b2a503b0e8bf3084fbe9237faa">haltonSequence(size_t base, size_t numberOfPoints)</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of the resulting <a class="el" href="classinviwo_1_1Volume.html">Volume</a>. </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>number of points to generate </td></tr>
    <tr><td class="paramname">baseX</td><td>base used for the fractions to generate the x-values </td></tr>
    <tr><td class="paramname">baseY</td><td>base used for the fractions to generate the y-values </td></tr>
    <tr><td class="paramname">baseZ</td><td>base used for the fractions to generate the z-values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69ec75b2a503b0e8bf3084fbe9237faa" name="a69ec75b2a503b0e8bf3084fbe9237faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ec75b2a503b0e8bf3084fbe9237faa">&#9670;&nbsp;</a></span>haltonSequence() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; inviwo::util::haltonSequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate a sequence of length numberOfPoints of pseduo-random numbers on the open range (0 1). </p><dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Halton_sequence">https://en.wikipedia.org/wiki/Halton_sequence</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>what base to use to generate fractions </td></tr>
    <tr><td class="paramname">numberOfPoints</td><td>amount of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a903ca9372bd3a12d9a2579ac7c99c890" name="a903ca9372bd3a12d9a2579ac7c99c890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ca9372bd3a12d9a2579ac7c99c890">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void inviwo::util::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Function to combine several hash values <a href="http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x">http://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x</a> </p>

</div>
</div>
<a id="a72163c26b092ba2ad01a8ba8af763d59" name="a72163c26b092ba2ad01a8ba8af763d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72163c26b092ba2ad01a8ba8af763d59">&#9670;&nbsp;</a></span>iCaseEndsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::util::iCaseEndsWith </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if provided string ends with suffix using case insensitive equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to check last part of. Allowed to be smaller than suffix. </td></tr>
    <tr><td class="paramname">suffix</td><td>Ending to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if last part of str is equal to suffix, false otherwise. </dd></dl>

</div>
</div>
<a id="a94ab080660bf20a19c866ba0e82ea7f6" name="a94ab080660bf20a19c866ba0e82ea7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ab080660bf20a19c866ba0e82ea7f6">&#9670;&nbsp;</a></span>importFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_QTWIDGETS_API void inviwo::util::importFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1TFPrimitiveSet.html">TFPrimitiveSet</a> &amp;&#160;</td>
          <td class="paramname"><em>primitiveSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shows an <a class="el" href="classinviwo_1_1InviwoFileDialog.html">InviwoFileDialog</a> to import a <a class="el" href="classinviwo_1_1TFPrimitiveSet.html" title="data structure managing multiple TFPrimitives">TFPrimitiveSet</a> from a file. Depending on the underlying type of <code>primitiveSet</code>, either TF primitives or isovalues are imported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveSet</td><td>target primitive set which might either be a TF or isovalues </td></tr>
    <tr><td class="paramname">parent</td><td>parent widget of the file dialog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a255656e04e9caab0092cefb2387b522c" name="a255656e04e9caab0092cefb2387b522c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255656e04e9caab0092cefb2387b522c">&#9670;&nbsp;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Tuple , size_t count = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t inviwo::util::index_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the index of a type in a tuple, returns the index of the first matching type </p>

</div>
</div>
<a id="a144ffacb1ddf668f23cac00ffca4071a" name="a144ffacb1ddf668f23cac00ffca4071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ffacb1ddf668f23cac00ffca4071a">&#9670;&nbsp;</a></span>index_of_derived()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename Tuple , size_t count = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t inviwo::util::index_of_derived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the index of the first type in the Tuple that is derived from T </p>

</div>
</div>
<a id="a7669f35617341a0ec4465acb3a0b4a93" name="a7669f35617341a0ec4465acb3a0b4a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7669f35617341a0ec4465acb3a0b4a93">&#9670;&nbsp;</a></span>interpolateAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::interpolateAlpha </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1TFPrimitive.html">TFPrimitive</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Interpolate the alpha values of selected primitives in between the first and the last primitive based on their relative position. </p>

</div>
</div>
<a id="a9043d4a86a79be19df535ce9731f0153" name="a9043d4a86a79be19df535ce9731f0153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9043d4a86a79be19df535ce9731f0153">&#9670;&nbsp;</a></span>is_callable_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... A, typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool inviwo::util::is_callable_with </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A type trait to determine if type "callback" can be called with certain arguments. Example: util::is_callable_with&lt;float&gt;(callback) where callback = [](float){} -&gt; true callback = [](std::string){} -&gt; false </p>

</div>
</div>
<a id="aa048b0cf2e27625499d9ac8e03af03d6" name="aa048b0cf2e27625499d9ac8e03af03d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa048b0cf2e27625499d9ac8e03af03d6">&#9670;&nbsp;</a></span>isConvex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isConvex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether the given polygon is convex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>polygon consisting of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the polygon is convex, false otherwise </dd></dl>

</div>
</div>
<a id="a193aac2254d9cc5b5b1029995323d957" name="a193aac2254d9cc5b5b1029995323d957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193aac2254d9cc5b5b1029995323d957">&#9670;&nbsp;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; <a class="el" href="structinviwo_1_1util_1_1rank.html">util::rank</a>&lt; T &gt;::value==1 &amp;&amp;<a class="el" href="structinviwo_1_1util_1_1extent.html">util::extent</a>&lt; T &gt;::value==2, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool inviwo::util::isInside </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a given point lies within the convex hull </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>convex hull </td></tr>
    <tr><td class="paramname">p</td><td>point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point lies inside the convex hull </dd></dl>

</div>
</div>
<a id="a33720f81ed26a3562c7447ce9eb89288" name="a33720f81ed26a3562c7447ce9eb89288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33720f81ed26a3562c7447ce9eb89288">&#9670;&nbsp;</a></span>isSelected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API bool inviwo::util::isSelected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the selection state of processor. </p>

</div>
</div>
<a id="a90dfea83005204a1c4beaa3714c38e74" name="a90dfea83005204a1c4beaa3714c38e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dfea83005204a1c4beaa3714c38e74">&#9670;&nbsp;</a></span>layerRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::layerRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>outDistanceField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 2, U &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size2_t&#160;</td>
          <td class="paramname"><em>upsample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform&#160;</td>
          <td class="paramname"><em>valueTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implementation of Euclidean Distance <a class="el" href="classinviwo_1_1Transform.html">Transform</a> according to Saito's algorithm: T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p >Calculates the distance in base mat space</p><ul>
<li>Predicate is a function of type (const T &amp;value) -&gt; bool to deside if a value in the input is a "feature".</li>
<li>ValueTransform is a function of type (const U&amp; squaredDist) -&gt; U that is appiled to all squared distance values at the end of the calculation.</li>
<li>ProcessCallback is a function of type (double progress) -&gt; void that is called with a value from 0 to 1 to indicate the progress of the calculation. </li>
</ul>

</div>
</div>
<a id="ab36aead3fc89df1f8274c4a4ad543f2b" name="ab36aead3fc89df1f8274c4a4ad543f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36aead3fc89df1f8274c4a4ad543f2b">&#9670;&nbsp;</a></span>layerSubSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAM.html">LayerRAM</a> &gt; inviwo::util::layerSubSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clampBorderOutsideImage</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts a subregion from a layer and returns it as a new layer </p>
<p >This function extracts a subregion given by offset and extent from the input layer. If border clamping is enabled, the output region will be clamped to lie completely within the source layer. Otherwise (default), the areas outside the source layer will be filled with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input layer </td></tr>
    <tr><td class="paramname">offset</td><td>subregion offset in input layer </td></tr>
    <tr><td class="paramname">extent</td><td>extent (width and height) of subregion </td></tr>
    <tr><td class="paramname">clampBorderOutsideImage</td><td>if true, the output region is clamped to the layer boundaries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;LayerRAM&gt; </dd></dl>

</div>
</div>
<a id="a96f9760ea8997e2913a393a5b0f00baa" name="a96f9760ea8997e2913a393a5b0f00baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f9760ea8997e2913a393a5b0f00baa">&#9670;&nbsp;</a></span>layerSubSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1LayerRAMPrecision.html">LayerRAMPrecision</a>&lt; T &gt; &gt; inviwo::util::layerSubSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clampBorderOutsideImage</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts a subregion from a layer and converts it into a new layer </p>
<p >This function extracts a subregion given by offset and extent from the input layer. The values will be converted to type T using util::glm_convert_normalized. If border clamping is enabled, the output region will be clamped to lie completely within the source layer. Otherwise (default), the areas outside the source layer will be filled with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input layer </td></tr>
    <tr><td class="paramname">offset</td><td>subregion offset in input layer </td></tr>
    <tr><td class="paramname">extent</td><td>extent (width and height) of subregion </td></tr>
    <tr><td class="paramname">clampBorderOutsideImage</td><td>if true, the output region is clamped to the layer boundaries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;LayerRAMPrecision&lt;T&gt;&gt; </dd></dl>

</div>
</div>
<a id="aa566d97b543e2bdded79bb2a50c33bb0" name="aa566d97b543e2bdded79bb2a50c33bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa566d97b543e2bdded79bb2a50c33bb0">&#9670;&nbsp;</a></span>make_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::make_sequence </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>inc</em> = <code>T{1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structinviwo_1_1util_1_1sequence.html">sequence</a>&lt;T&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Convenvience function for creating a sequence. Use case example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> inc = 2; <span class="keyword">auto</span> end = 3;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; i : <a class="code hl_function" href="namespaceinviwo_1_1util.html#aa566d97b543e2bdded79bb2a50c33bb0">util::make_sequence</a>(0, end, inc)) {</div>
<div class="line">  <span class="comment">// Iterates over 0 and 2</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_aa566d97b543e2bdded79bb2a50c33bb0"><div class="ttname"><a href="namespaceinviwo_1_1util.html#aa566d97b543e2bdded79bb2a50c33bb0">inviwo::util::make_sequence</a></div><div class="ttdeci">auto make_sequence(const T &amp;begin, const T &amp;end, const T &amp;inc=T{1}) -&gt; sequence&lt; T &gt;</div><div class="ttdef"><b>Definition:</b> zip.h:539</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8bf61d0ad31846cd5659939c933633ff" name="a8bf61d0ad31846cd5659939c933633ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf61d0ad31846cd5659939c933633ff">&#9670;&nbsp;</a></span>makeIndirectIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool PropagateConst = true, typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a>&lt; Iter, PropagateConst &gt; inviwo::util::makeIndirectIterator </td>
          <td>(</td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create an <a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structinviwo_1_1util_1_1IndirectIterator.html">IndirectIterator</a> </dd></dl>

</div>
</div>
<a id="ab618818fcbf3c386f0f07928ce06821f" name="ab618818fcbf3c386f0f07928ce06821f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab618818fcbf3c386f0f07928ce06821f">&#9670;&nbsp;</a></span>makeMarchingCubeVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeMarchingCubeVolume </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A 2x2x2 volume corresponding to a marching cube case </p>

</div>
</div>
<a id="a743b3fa3cbde44118de690fe87a21113" name="a743b3fa3cbde44118de690fe87a21113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743b3fa3cbde44118de690fe87a21113">&#9670;&nbsp;</a></span>makeProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; inviwo::util::makeProcessor </td>
          <td>(</td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A utility function to create a processor and set identifier, display name, and position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Sets the position meta data of the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> </td></tr>
    <tr><td class="paramname">args</td><td>Any extra arguments to supply to the <a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5167c56b9fc5c53f102462d89bbf1f11" name="a5167c56b9fc5c53f102462d89bbf1f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5167c56b9fc5c53f102462d89bbf1f11">&#9670;&nbsp;</a></span>makeRippleVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeRippleVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A quickly oscillating density between 0 and 1 </p>

</div>
</div>
<a id="a5bb99c263ef07f00a0892cf1d9610d15" name="a5bb99c263ef07f00a0892cf1d9610d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb99c263ef07f00a0892cf1d9610d15">&#9670;&nbsp;</a></span>makeSingleVoxelVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeSingleVoxelVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Center voxel equal to 1 all other 0 </p>

</div>
</div>
<a id="a351bc675bcbde3fa893929b312a1b276" name="a351bc675bcbde3fa893929b312a1b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351bc675bcbde3fa893929b312a1b276">&#9670;&nbsp;</a></span>makeSphericalVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::makeSphericalVolume </td>
          <td>(</td>
          <td class="paramtype">const size3_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Spherically symmetric density centered in the volume decaying radially with the distance from the center </p>

</div>
</div>
<a id="a5bec0b925a8be26aebea592ce1b00fd2" name="a5bec0b925a8be26aebea592ce1b00fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bec0b925a8be26aebea592ce1b00fd2">&#9670;&nbsp;</a></span>marchingcubes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingcubes </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>std::function&lt;&#160;void(float)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts an isosurface from a volume using the Marching Cubes algorithm</p>
<p >Note: Share interface with <a class="el" href="namespaceinviwo_1_1util.html#ad05c658162fd0c9fb67eb70cfd537e52">util::marchingtetrahedron</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264903a207983c82b75a97aaa2a69545" name="a264903a207983c82b75a97aaa2a69545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264903a207983c82b75a97aaa2a69545">&#9670;&nbsp;</a></span>marchingCubesOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingCubesOpt </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts an iso surface from a volume using the Marching Cubes algorithm</p>
<p >Note: Shares interface with util::marchingcbes and <a class="el" href="namespaceinviwo_1_1util.html#ad05c658162fd0c9fb67eb70cfd537e52">util::marchingtetrahedron</a> This is an optimized version of <a class="el" href="namespaceinviwo_1_1util.html#a5bec0b925a8be26aebea592ce1b00fd2">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the iso surface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], useful for progress bars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad05c658162fd0c9fb67eb70cfd537e52" name="ad05c658162fd0c9fb67eb70cfd537e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05c658162fd0c9fb67eb70cfd537e52">&#9670;&nbsp;</a></span>marchingtetrahedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Mesh.html">Mesh</a> &gt; inviwo::util::marchingtetrahedron </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4 &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enclose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(float)&gt;&#160;</td>
          <td class="paramname"><em>progressCallback</em> = <code>std::function&lt;&#160;void(float)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const size3_t &amp;)&gt;&#160;</td>
          <td class="paramname"><em>maskingCallback</em> = <code>[](const&#160;size3_t&#160;&amp;)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extracts an isosurface from a volume using the Marching Tetrahedron algorithm</p>
<p >Note: Share interface with <a class="el" href="namespaceinviwo_1_1util.html#a5bec0b925a8be26aebea592ce1b00fd2">util::marchingcubes</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the scalar volume </td></tr>
    <tr><td class="paramname">iso</td><td>iso-value for the extracted surface </td></tr>
    <tr><td class="paramname">color</td><td>the color of the resulting surface </td></tr>
    <tr><td class="paramname">invert</td><td>flips the normals of the surface normals (useful when values greater than the iso-value is 'outside' of the surface) </td></tr>
    <tr><td class="paramname">enclose</td><td>whether to create surface where the isosurface intersects the volume boundaries </td></tr>
    <tr><td class="paramname">progressCallback</td><td>if set, will be called will executing with the current progress in the interval [0,1], usefull for progressbars </td></tr>
    <tr><td class="paramname">maskingCallback</td><td>optional callback to test whether current cell should be evaluated or not (return true to include current cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1341a5fe91b0d7f378da017b90eb3779" name="a1341a5fe91b0d7f378da017b90eb3779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1341a5fe91b0d7f378da017b90eb3779">&#9670;&nbsp;</a></span>offsetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::offsetPosition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Offset all the positions of the processors in the list by offset </p>

</div>
</div>
<a id="ada3f90c8cfa64a0898b021cca551de05" name="ada3f90c8cfa64a0898b021cca551de05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3f90c8cfa64a0898b021cca551de05">&#9670;&nbsp;</a></span>ordinalColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalPropertyState.html">OrdinalPropertyState</a>&lt; vec4 &gt; inviwo::util::ordinalColor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a>&#160;</td>
          <td class="paramname"><em>invalidationLevel</em> = <code>InvalidationLevel::InvalidOutput</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A factory function for OrdinalProperties representing Colors When instantiating a Ordinal <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> for a color value one would need to write something along there lines </p><div class="fragment"><div class="line">color(<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, vec4(0.11f, 0.42f, 0.63f, 1.0f),</div>
<div class="line">     {vec4(0.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>},</div>
<div class="line">     {vec4(1.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>}, vec4(0.01f),</div>
<div class="line">     InvalidationLevel::InvalidOutput, PropertySemantics::Color)</div>
<div class="ttc" id="anamespaceinviwo_html_ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc"><div class="ttname"><a href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">inviwo::ConstraintBehavior::Immutable</a></div><div class="ttdeci">@ Immutable</div></div>
</div><!-- fragment --><p> by using the helper function most of the boilerplate can be removed: </p><div class="fragment"><div class="line">color{<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, <a class="code hl_function" href="namespaceinviwo_1_1util.html#ada3f90c8cfa64a0898b021cca551de05">util::ordinalColor</a>(0.11f, 0.42f, 0.63f)}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_ada3f90c8cfa64a0898b021cca551de05"><div class="ttname"><a href="namespaceinviwo_1_1util.html#ada3f90c8cfa64a0898b021cca551de05">inviwo::util::ordinalColor</a></div><div class="ttdeci">IVW_CORE_API OrdinalPropertyState&lt; vec4 &gt; ordinalColor(float r, float g, float b, float a=1.0f, InvalidationLevel invalidationLevel=InvalidationLevel::InvalidOutput)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78fe508315d93a69417c6ee9614303d6" name="a78fe508315d93a69417c6ee9614303d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fe508315d93a69417c6ee9614303d6">&#9670;&nbsp;</a></span>ordinalRefColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="structinviwo_1_1OrdinalRefPropertyState.html">OrdinalRefPropertyState</a>&lt; vec4 &gt; inviwo::util::ordinalRefColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceinviwo.html#ae0b7ff1e08626f6ee58e561ef4c9ffba">InvalidationLevel</a>&#160;</td>
          <td class="paramname"><em>invalidationLevel</em> = <code>InvalidationLevel::InvalidOutput</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A factory function for OrdinalProperties representing Colors When instantiating a Ordinal <a class="el" href="classinviwo_1_1Property.html" title="A Property represents a parameter to a processor.">Property</a> for a color value one would need to write something along there lines </p><div class="fragment"><div class="line">color(<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, vec4(0.11f, 0.42f, 0.63f, 1.0f),</div>
<div class="line">     {vec4(0.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>},</div>
<div class="line">     {vec4(1.0f), <a class="code hl_enumvalue" href="namespaceinviwo.html#ae77b6d9d2b2e55861c15fff3dc8854fba11efd9ae6f76e706e3f1b34d97584ebc">ConstraintBehavior::Immutable</a>}, vec4(0.01f),</div>
<div class="line">     InvalidationLevel::InvalidOutput, PropertySemantics::Color)</div>
</div><!-- fragment --><p> by using the helper function most of the boilerplate can be removed: </p><div class="fragment"><div class="line">color{<span class="stringliteral">&quot;cubeColor&quot;</span>, <span class="stringliteral">&quot;Cube Color&quot;</span>, <a class="code hl_function" href="namespaceinviwo_1_1util.html#ada3f90c8cfa64a0898b021cca551de05">util::ordinalColor</a>()}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a150bfe1458dc7fdc648881f4e9abc5ce" name="a150bfe1458dc7fdc648881f4e9abc5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150bfe1458dc7fdc648881f4e9abc5ce">&#9670;&nbsp;</a></span>perlinNoise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt; inviwo::util::perlinNoise </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>persistence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with perlin noise, a cloud like noise using the sum of several white noise images with different frequencies </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">persistence</td><td>controls the amplitude used in the different frequencies </td></tr>
    <tr><td class="paramname">startLevel</td><td>controls the min level used. The level is determining the frequency to use in each white noise image as 2^level </td></tr>
    <tr><td class="paramname">endLevel</td><td>controlsthe max level used. </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1acaaeed4f22315384c0468633ff1bb2" name="a1acaaeed4f22315384c0468633ff1bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acaaeed4f22315384c0468633ff1bb2">&#9670;&nbsp;</a></span>poissonDisk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rand  = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt; inviwo::util::poissonDisk </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poissonDotsAlongX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with sparse noise based on the perlin noise algorith. </p><dl class="section see"><dt>See also</dt><dd><a href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/">http://devmag.org.za/2009/05/03/poisson-disk-sampling/</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">poissonDotsAlongX</td><td>controlls the amount on points there is on average per line, set the minimum distance between points </td></tr>
    <tr><td class="paramname">maxPoints</td><td>a fallback variable to prevent generating to many points </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23a6f24d3a7fd9df567712ff831321df" name="a23a6f24d3a7fd9df567712ff831321df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6f24d3a7fd9df567712ff831321df">&#9670;&nbsp;</a></span>randomImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Image.html">Image</a> &gt; inviwo::util::randomImage </td>
          <td>(</td>
          <td class="paramtype">size2_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Image.html">Image</a> with white noise based using C++ a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output image </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b2f672f99a31ee8b19f6f40fa768cb" name="a48b2f672f99a31ee8b19f6f40fa768cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2f672f99a31ee8b19f6f40fa768cb">&#9670;&nbsp;</a></span>randomSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::randomSequence </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fills a data container of type T with numberOfElements random numbers using the given random number generator and distribution </p>

</div>
</div>
<a id="a27779344a8c3a59f6cb41222bea0b8e2" name="a27779344a8c3a59f6cb41222bea0b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27779344a8c3a59f6cb41222bea0b8e2">&#9670;&nbsp;</a></span>randomVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Rand  = std::mt19937, typename Dist  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value,                                                    std::uniform_int_distribution&lt;T&gt;,                                                    std::uniform_real_distribution&lt;T&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::randomVolume </td>
          <td>(</td>
          <td class="paramtype">size3_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rand &amp;&#160;</td>
          <td class="paramname"><em>randomNumberGenerator</em> = <code>Rand()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dist &amp;&#160;</td>
          <td class="paramname"><em>distribution</em> = <code>Dist(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generate an <a class="el" href="classinviwo_1_1Volume.html">Volume</a> with white noise based using C++ a given random number generator and distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Size of the output <a class="el" href="classinviwo_1_1Volume.html">Volume</a> </td></tr>
    <tr><td class="paramname">randomNumberGenerator</td><td>the Random number generator to use, defaults to the Mersenne Twister engine (std::mt19937) </td></tr>
    <tr><td class="paramname">distribution</td><td>the distribution to use for the random numbers, defaults to std::uniform_int/real_distribution between zero and one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac526048b608d9c8b31251eb6d4c633e4" name="ac526048b608d9c8b31251eb6d4c633e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac526048b608d9c8b31251eb6d4c633e4">&#9670;&nbsp;</a></span>replaceSelectionWithCompositeProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::replaceSelectionWithCompositeProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1ProcessorNetwork.html">ProcessorNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classinviwo_1_1CompositeProcessor.html" title="A processor containing a network of processors, i.e. it will act as a sub network within a processor ...">CompositeProcessor</a> out of the currently selected processors and replace them with the composite processors. The selected processors are moved from the current network into the sub network of the composite processor. For each port connection between a selected and unselected processor a composite sink or composite source processor is added to the sub network and connections are made from the selected processor to the sink/source and from the composite processor to the unselected processor. For each link between a selected and unselected processor, a super property is added to the composite processor and the link added to it. </p>

</div>
</div>
<a id="ac1a7add893c040adf20aa7bfb32b6aa7" name="ac1a7add893c040adf20aa7bfb32b6aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7add893c040adf20aa7bfb32b6aa7">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1BufferBase.html">BufferBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to reverse the orders of the elements in a buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the buffer to reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e9514f43e3c6ac74e6bfd2fa4f2acec" name="a4e9514f43e3c6ac74e6bfd2fa4f2acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9514f43e3c6ac74e6bfd2fa4f2acec">&#9670;&nbsp;</a></span>saveData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::saveData </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Save <code>data</code> to <code>filePath</code> using the writer given by <code>extension</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Object to save to file </td></tr>
    <tr><td class="paramname">filePath</td><td>Complete path, name, and extension of the written file </td></tr>
    <tr><td class="paramname">extension</td><td>The extension used to identifier the <a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> in the factory </td></tr>
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite any existing file or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1DataWriterException.html">DataWriterException</a></td><td>if no write could be found, or if overwrite was violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a128732ec0a0dabddb2e4f0aca274edab" name="a128732ec0a0dabddb2e4f0aca274edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128732ec0a0dabddb2e4f0aca274edab">&#9670;&nbsp;</a></span>saveData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; inviwo::util::saveData </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1FileExtension.html">FileExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Save <code>data</code> to the filePath given by concatenating <code>path</code>, "/", <code>name</code>, ".", and extension where extensions is the first extension in <code>extensions</code> that we find a matching writer for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Object to save to file </td></tr>
    <tr><td class="paramname">path</td><td>Directory where the file will be written </td></tr>
    <tr><td class="paramname">name</td><td>Name of the file excluding extension </td></tr>
    <tr><td class="paramname">extensions</td><td>A list of extensions to use for finding a matching <a class="el" href="classinviwo_1_1DataWriter.html" title="A abstract base class for all file writers.">DataWriter</a> </td></tr>
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite any existing file or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full path to the file written or std::nullopt if no writer was found </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1DataWriterException.html">DataWriterException</a></td><td>if overwrite was violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164993d46bdb58f8b16a943c65ae4b9c" name="a164993d46bdb58f8b16a943c65ae4b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164993d46bdb58f8b16a943c65ae4b9c">&#9670;&nbsp;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivec2&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the position of processor to pos </p>

</div>
</div>
<a id="af6fa91973f804cd02c1e28fb635202d1" name="af6fa91973f804cd02c1e28fb635202d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fa91973f804cd02c1e28fb635202d1">&#9670;&nbsp;</a></span>setSelected() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classinviwo_1_1Processor.html">Processor</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>processors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the listed processors as selected or unSelected. </p>

</div>
</div>
<a id="a78172b271a10c03a2bb4a1a41bbde23e" name="a78172b271a10c03a2bb4a1a41bbde23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78172b271a10c03a2bb4a1a41bbde23e">&#9670;&nbsp;</a></span>setSelected() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API void inviwo::util::setSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the selection state of processor </p>

</div>
</div>
<a id="a68531c2a1a0d7b50fbcd32b4ab6d03a2" name="a68531c2a1a0d7b50fbcd32b4ab6d03a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68531c2a1a0d7b50fbcd32b4ab6d03a2">&#9670;&nbsp;</a></span>splitByFirst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByFirst </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the first instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will be the same as the input str, and the second one will be empty </dd></dl>

</div>
</div>
<a id="a72e4709f37d1f58ead6f6bb699964102" name="a72e4709f37d1f58ead6f6bb699964102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e4709f37d1f58ead6f6bb699964102">&#9670;&nbsp;</a></span>splitByFirst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByFirst </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the first instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will be the same as the input str, and the second one will be empty </dd></dl>

</div>
</div>
<a id="a7062e820ba75f7fb44e8b149e52dd979" name="a7062e820ba75f7fb44e8b149e52dd979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7062e820ba75f7fb44e8b149e52dd979">&#9670;&nbsp;</a></span>splitByLast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByLast </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the last instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will empty, and the second one will be equal to the input str </dd></dl>

</div>
</div>
<a id="a22420f375af97c3654f65bd70c7df79c" name="a22420f375af97c3654f65bd70c7df79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22420f375af97c3654f65bd70c7df79c">&#9670;&nbsp;</a></span>splitByLast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; std::string_view, std::string_view &gt; inviwo::util::splitByLast </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a string into two parts by the last instance of a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to divide </td></tr>
    <tr><td class="paramname">delimiter</td><td>not include in either returned strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of strings, if the delimiter is not found the first string will empty, and the second one will be equal to the input str </dd></dl>

</div>
</div>
<a id="ab608fdeb665bcddf5e9821006487364b" name="ab608fdeb665bcddf5e9821006487364b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab608fdeb665bcddf5e9821006487364b">&#9670;&nbsp;</a></span>splitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string &gt; inviwo::util::splitString </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb. </p>
<dl class="section note"><dt>Note</dt><dd>Empty substrings are not skipped, ";;" will generate an element. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character use for splitting (default to space) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the substrings as std::string </dd></dl>

</div>
</div>
<a id="a018c12bda5703660547faff1bd31b8b9" name="a018c12bda5703660547faff1bd31b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018c12bda5703660547faff1bd31b8b9">&#9670;&nbsp;</a></span>splitStringView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::vector&lt; std::string_view &gt; inviwo::util::splitStringView </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into substrings based on separating delimiter character. Using delimiter ';' on string "aa;bb" will result in a vector contaning aa and bb. </p>
<dl class="section note"><dt>Note</dt><dd>Empty substrings are not skipped, ";;" will generate an element. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character use for splitting (default to space) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the substrings as std::string_view </dd></dl>

</div>
</div>
<a id="a35c62a1beeaef244810ed786c86d2074" name="a35c62a1beeaef244810ed786c86d2074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c62a1beeaef244810ed786c86d2074">&#9670;&nbsp;</a></span>stripModuleFileNameDecoration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::string inviwo::util::stripModuleFileNameDecoration </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes inviwo-module from module library file name. Turns "/path/to/inviwo-module-yourmodule.dll" into "yourmodule". Returns filename without extension if inviwo-module was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to module file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the module </dd></dl>

</div>
</div>
<a id="ac562f60680204dda73a7d29d9c9ddb24" name="ac562f60680204dda73a7d29d9c9ddb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac562f60680204dda73a7d29d9c9ddb24">&#9670;&nbsp;</a></span>toWstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API std::wstring inviwo::util::toWstring </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the given std::string to std::wstring. On Windows, MultiByteToWideChar is used for this conversion assuming utf8 encoding. Otherwise, std::mbsrtowcs is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>multibyte character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to std::wstring </dd></dl>

</div>
</div>
<a id="aeb3562b94700f15c08e99b826745258a" name="aeb3562b94700f15c08e99b826745258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3562b94700f15c08e99b826745258a">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view inviwo::util::trim </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>trims <code>str</code> from beginning and end by removing white spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>trimmed stringview without leading/trailing white space </dd></dl>

</div>
</div>
<a id="a9bb4e1d0a952f2a8216385f68ac32178" name="a9bb4e1d0a952f2a8216385f68ac32178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb4e1d0a952f2a8216385f68ac32178">&#9670;&nbsp;</a></span>trySetProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; inviwo::util::trySetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1Processor.html">Processor</a> *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to set a processor's property to a given value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of <code>proc</code>. </td></tr>
    <tr><td class="paramname">V</td><td>Type of <code>val</code>, deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td><a class="el" href="classinviwo_1_1Processor.html" title="A processor generally performs operation on input data and outputs the new result.">Processor</a> that has the target property. </td></tr>
    <tr><td class="paramname">identifier</td><td>Identifier of the property to be set. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">recursive</td><td>Enable/Disable recursive search for Processor::getPropertyByIdentifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to set property. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classinviwo_1_1Exception.html">Exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47927175e2344c3b515b14d86e5c508e" name="a47927175e2344c3b515b14d86e5c508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47927175e2344c3b515b14d86e5c508e">&#9670;&nbsp;</a></span>updateDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::updateDefaultState </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverwriteState&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the default state of <code>property</code> to <code>state</code> and set the current state to <code>state</code> if <code>property</code> is in the default state or <code>overwrite</code> is OverwriteState::Yes </p>

</div>
</div>
<a id="aa4d38c8a311e159b1bdb778697984dbe" name="aa4d38c8a311e159b1bdb778697984dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d38c8a311e159b1bdb778697984dbe">&#9670;&nbsp;</a></span>updateOrCreateCameraEyeOffsetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatVec2RefProperty</a> * inviwo::util::updateOrCreateCameraEyeOffsetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; vec2()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const vec2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing eye offset property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="aa25faca6335f85635cde61c0986c2343" name="aa25faca6335f85635cde61c0986c2343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25faca6335f85635cde61c0986c2343">&#9670;&nbsp;</a></span>updateOrCreateCameraFovProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::updateOrCreateCameraFovProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing vertical fov property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1PerspectiveCamera.html">PerspectiveCamera</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1SkewedPerspectiveCamera.html" title="Camera with off axis perspective projection.">SkewedPerspectiveCamera</a> </dd></dl>

</div>
</div>
<a id="ab27d645275cb437d22b94f20ddfe611a" name="ab27d645275cb437d22b94f20ddfe611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27d645275cb437d22b94f20ddfe611a">&#9670;&nbsp;</a></span>updateOrCreateCameraWidthProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_CORE_API <a class="el" href="classinviwo_1_1OrdinalRefProperty.html">FloatRefProperty</a> * inviwo::util::updateOrCreateCameraWidthProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1CameraProperty.html">CameraProperty</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float()&gt;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const float &amp;)&gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either return an existing width property updated with the provided get and set functions or create a new one. The new one will automatically be added to the camera property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1OrthographicCamera.html" title="Camera with no perspective projection. Objects far away will appear as large as objects close.">OrthographicCamera</a> </dd></dl>

</div>
</div>
<a id="aa893e468e6145d6106135461cd962371" name="aa893e468e6145d6106135461cd962371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa893e468e6145d6106135461cd962371">&#9670;&nbsp;</a></span>volumeRAMDistanceTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Predicate , typename ValueTransform , typename ProgressCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inviwo::util::volumeRAMDistanceTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinviwo_1_1VolumeRAMPrecision.html">VolumeRAMPrecision</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>outDistanceField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; 3, U &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size3_t&#160;</td>
          <td class="paramname"><em>upsample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTransform&#160;</td>
          <td class="paramname"><em>valueTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProgressCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implementation of Euclidean Distance <a class="el" href="classinviwo_1_1Transform.html">Transform</a> according to Saito's algorithm: T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance transformations of an n-dimensional digitized picture with applications. Pattern Recognition, 27(11). pp. 1551-1565, 1994. <a href="http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Saito94.pdf</a></p>
<p >Calculates the distance in grid index space</p><ul>
<li>Predicate is a function of type (const T &amp;value) -&gt; bool to deside if a value in the input is a "feature".</li>
<li>ValueTransform is a function of type (const U&amp; squaredDist) -&gt; U that is appiled to all squared distance values at the end of the calculation.</li>
<li>ProcessCallback is a function of type (double progress) -&gt; void that is called with a value from 0 to 1 to indicate the progress of the calculation. </li>
</ul>

</div>
</div>
<a id="a432f4a17defd07381043d6cf56c8ec9b" name="a432f4a17defd07381043d6cf56c8ec9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432f4a17defd07381043d6cf56c8ec9b">&#9670;&nbsp;</a></span>voronoiSegmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::shared_ptr&lt; <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &gt; inviwo::util::voronoiSegmentation </td>
          <td>(</td>
          <td class="paramtype">const size3_t&#160;</td>
          <td class="paramname"><em>volumeDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat4 &amp;&#160;</td>
          <td class="paramname"><em>indexToModelMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; uint32_t, vec3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>seedPointsWithIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Wrapping3D &amp;&#160;</td>
          <td class="paramname"><em>wrapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implementation of Voronoi segmentation.</p>
<p >The function returns a volume with each voxel containing the index for the closest seed point (according to the power distance with or without weights). </p><pre class="fragment">* volumeDimensions is the dimensions for the volume.
* indexToModelMatrix is the matrix to transform the voxel positions from index to model
  space.
* seedPointsWithIndices is a vector containing the seed points for the algorithm together
  with their index number on the form {index, position}. The positions are expected be in
  model space.
* wrapping the wrapping mode of the volume, @see Wrapping3D.
* weigths is an optional vector containing the weights for each seed point. If set the
  weighted version of voronoi should be used.
</pre> 
</div>
</div>
<a id="a4fde21434664ba9e965614cfdf7890fc" name="a4fde21434664ba9e965614cfdf7890fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fde21434664ba9e965614cfdf7890fc">&#9670;&nbsp;</a></span>voxelVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double IVW_CORE_API inviwo::util::voxelVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinviwo_1_1Volume.html">Volume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the volume of a single voxel, taking the basis and the dimensions into account The units of the result is in the unit as the basis vectors ^3 </p>
<dl class="section return"><dt>Returns</dt><dd>volume of one voxel </dd></dl>

</div>
</div>
<a id="a1fe22f3aa958e54a96079843918c9a3d" name="a1fe22f3aa958e54a96079843918c9a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe22f3aa958e54a96079843918c9a3d">&#9670;&nbsp;</a></span>writeIvfVolumeSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IVW_MODULE_BASE_API std::string inviwo::util::writeIvfVolumeSequence </td>
          <td>(</td>
          <td class="paramtype">const VolumeSequence &amp;&#160;</td>
          <td class="paramname"><em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>relativePathToElements</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Overwrite&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>Overwrite::Yes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a volume sequence to disk. </p>
<p >Writes a volume sequence to disk. Will create one main file ([name].ivfs) and a series of ivf volumes ([name]xx.ivf), one for each element in the sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumes</td><td>The volume sequence to export </td></tr>
    <tr><td class="paramname">name</td><td>the name of the dataset, will be used for to name the output files [name].ivfs and [name]xx.ivf </td></tr>
    <tr><td class="paramname">path</td><td>path to the folder to put the main file </td></tr>
    <tr><td class="paramname">relativePathToElements</td><td>relative path (from the path to the main file) to where the sequence elements will be written </td></tr>
    <tr><td class="paramname">overwrite</td><td>whether or not to overwrite existing files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>path to the created main-file </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinviwo_1_1IvfSequenceVolumeWriter.html" title="Writter for *.ivfs sequnce files.">inviwo::IvfSequenceVolumeWriter</a> </dd>
<dd>
<a class="el" href="classinviwo_1_1IvfSequenceVolumeReader.html" title="Reader for *.ivfs sequnce files.">inviwo::IvfSequenceVolumeReader</a> </dd></dl>

</div>
</div>
<a id="a2ec11e63479fff3c005d159414687d4e" name="a2ec11e63479fff3c005d159414687d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec11e63479fff3c005d159414687d4e">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto inviwo::util::zip </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structinviwo_1_1util_1_1detailzip_1_1zipper.html">detailzip::zipper</a>&lt;T...&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterate over containers in sync. Example use case 1: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; a(10);</div>
<div class="line">std::vector&lt;int&gt; b(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; i : <a class="code hl_function" href="namespaceinviwo_1_1util.html#a2ec11e63479fff3c005d159414687d4e">util::zip</a>(a, b)) {</div>
<div class="line">     std::cout &lt;&lt; i.first() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.second() &lt;&lt; std::endl;</div>
<div class="line">     <span class="comment">// alternatively, get&lt;0&gt;(i) and get&lt;1&gt;(i) can be used</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a2ec11e63479fff3c005d159414687d4e"><div class="ttname"><a href="namespaceinviwo_1_1util.html#a2ec11e63479fff3c005d159414687d4e">inviwo::util::zip</a></div><div class="ttdeci">auto zip(T &amp;&amp;... args) -&gt; detailzip::zipper&lt; T... &gt;</div><div class="ttdef"><b>Definition:</b> zip.h:430</div></div>
</div><!-- fragment --><p >with C++17 structured bindings: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [i, j] : <a class="code hl_function" href="namespaceinviwo_1_1util.html#a787f4da3b201153820af19c27c2a7fac">util::enumerate</a>(vec)) {</div>
<div class="line">     std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinviwo_1_1util_html_a787f4da3b201153820af19c27c2a7fac"><div class="ttname"><a href="namespaceinviwo_1_1util.html#a787f4da3b201153820af19c27c2a7fac">inviwo::util::enumerate</a></div><div class="ttdeci">auto enumerate(T &amp;&amp;cont, Ts &amp;&amp;... conts)</div><div class="ttdef"><b>Definition:</b> zip.h:559</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6c6f2c783a1cc78c23c5060fc9e8425e" name="a6c6f2c783a1cc78c23c5060fc9e8425e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6f2c783a1cc78c23c5060fc9e8425e">&#9670;&nbsp;</a></span>fmtHelp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto inviwo::util::fmtHelp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= IVW_UNINDENT(R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">    To locate the error try breaking on fmt::format_error exceptions,</span></div>
<div class="line"><span class="stringliteral">    or put a breakpoint in fmt::detail::error_handler::on_error.</span></div>
<div class="line"><span class="stringliteral">    in lldb try &quot;breakpoint set -E c++ -O fmt::format_error&quot;</span></div>
<div class="line"><span class="stringliteral">    or &quot;breakpoint set -M fmt::v7::detail::error_handler::on_error&quot;.</span></div>
<div class="line"><span class="stringliteral">    )&quot;)</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinviwo.html">inviwo</a></li><li class="navelem"><a class="el" href="namespaceinviwo_1_1util.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
